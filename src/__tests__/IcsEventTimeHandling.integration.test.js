/**
 * ICS Event Time Handling Integration Test
 * End-to-end test for ICS event time preservation and enhanced parsing
 */
import { IcsManager } from "../managers/ics-manager";
import { TimeParsingService } from "../services/time-parsing-service";
import { IcsParser } from "../parsers/ics-parser";
// Mock Obsidian Component
jest.mock("obsidian", () => ({
    Component: class MockComponent {
        constructor() { }
        load() { }
        unload() { }
        onload() { }
        onunload() { }
        addChild() { }
        removeChild() { }
        register() { }
    },
    requestUrl: jest.fn(),
}));
// Mock minimal settings for testing
const mockPluginSettings = {
    taskStatusMarks: {
        "Not Started": " ",
        "In Progress": "/",
        Completed: "x",
        Abandoned: "-",
        Planned: "?",
    },
};
// Mock time parsing config
const mockTimeParsingConfig = {
    enabled: true,
    supportedLanguages: ["en", "zh"],
    dateKeywords: {
        start: ["start", "from", "begins"],
        due: ["due", "by", "until"],
        scheduled: ["at", "on", "scheduled"],
    },
    removeOriginalText: false,
    perLineProcessing: true,
    realTimeReplacement: false,
};
describe("ICS Event Time Handling Integration", () => {
    let icsManager;
    let timeParsingService;
    beforeEach(() => {
        timeParsingService = new TimeParsingService(mockTimeParsingConfig);
        const testSource = {
            id: "integration-test",
            name: "Integration Test Calendar",
            url: "https://example.com/test.ics",
            enabled: true,
            refreshInterval: 60,
            showAllDayEvents: true,
            showTimedEvents: true,
            showType: "event",
        };
        const mockConfig = {
            sources: [testSource],
            globalRefreshInterval: 60,
            maxCacheAge: 24,
            enableBackgroundRefresh: false,
            networkTimeout: 30,
            maxEventsPerSource: 1000,
            showInCalendar: true,
            showInTaskLists: true,
            defaultEventColor: "#3498db",
        };
        icsManager = new IcsManager(mockConfig, mockPluginSettings, undefined, timeParsingService);
    });
    test("end-to-end ICS event with time components conversion", () => {
        var _a, _b, _c, _d;
        // Real-world ICS data with various time formats
        const icsData = `BEGIN:VCALENDAR
VERSION:2.0
PRODID:-//Test//Integration Test//EN
CALSCALE:GREGORIAN
BEGIN:VEVENT
UID:meeting-with-time@example.com
DTSTART:20240315T093000Z
DTEND:20240315T103000Z
SUMMARY:Team Standup
DESCRIPTION:Daily standup meeting for the development team
LOCATION:Conference Room A
STATUS:CONFIRMED
END:VEVENT
BEGIN:VEVENT
UID:workshop-allday@example.com
DTSTART;VALUE=DATE:20240316
DTEND;VALUE=DATE:20240317
SUMMARY:Workshop Day
DESCRIPTION:Full-day workshop from 9:00 AM to 5:00 PM with lunch break at 12:00-13:00
LOCATION:Training Center
STATUS:CONFIRMED
END:VEVENT
BEGIN:VEVENT
UID:dinner-event@example.com
DTSTART;VALUE=DATE:20240317
SUMMARY:Team Dinner
DESCRIPTION:Team dinner at the restaurant
LOCATION:Italian Restaurant at 7:30 PM
STATUS:CONFIRMED
END:VEVENT
END:VCALENDAR`;
        // Parse ICS data
        const testSource = icsManager.getConfig().sources[0];
        const parseResult = IcsParser.parse(icsData, testSource);
        expect(parseResult.events).toHaveLength(3);
        expect(parseResult.errors).toHaveLength(0);
        // Convert to tasks
        const tasks = icsManager.convertEventsToTasks(parseResult.events);
        expect(tasks).toHaveLength(3);
        // Test 1: Timed event with ICS time components
        const timedTask = tasks.find(t => t.content === "Team Standup");
        expect(timedTask).toBeDefined();
        const timedMetadata = timedTask.metadata;
        expect(timedMetadata.timeComponents).toBeDefined();
        expect((_a = timedMetadata.timeComponents) === null || _a === void 0 ? void 0 : _a.startTime).toBeDefined();
        expect((_b = timedMetadata.timeComponents) === null || _b === void 0 ? void 0 : _b.endTime).toBeDefined();
        expect(timedMetadata.enhancedDates).toBeDefined();
        expect((_c = timedMetadata.enhancedDates) === null || _c === void 0 ? void 0 : _c.startDateTime).toBeDefined();
        expect((_d = timedMetadata.enhancedDates) === null || _d === void 0 ? void 0 : _d.endDateTime).toBeDefined();
        // Test 2: All-day event with time parsing from description
        const workshopTask = tasks.find(t => t.content === "Workshop Day");
        expect(workshopTask).toBeDefined();
        const workshopMetadata = workshopTask.metadata;
        // Should have time components parsed from description
        expect(workshopMetadata.timeComponents).toBeDefined();
        expect(workshopMetadata.enhancedDates).toBeDefined();
        // Test 3: Event with time in location field
        const dinnerTask = tasks.find(t => t.content === "Team Dinner");
        expect(dinnerTask).toBeDefined();
        const dinnerMetadata = dinnerTask.metadata;
        // Should have time components parsed from location
        expect(dinnerMetadata.timeComponents).toBeDefined();
        expect(dinnerMetadata.enhancedDates).toBeDefined();
        // Verify all tasks maintain backward compatibility
        for (const task of tasks) {
            expect(task.id).toBeDefined();
            expect(task.content).toBeDefined();
            expect(task.filePath).toBe("ics://Integration Test Calendar");
            expect(task.icsEvent).toBeDefined();
            expect(task.readonly).toBe(true);
            expect(task.source.type).toBe("ics");
            expect(task.metadata.startDate).toBeDefined();
            expect(task.metadata.project).toBe("Integration Test Calendar");
        }
    });
    test("ICS event time preservation with holiday detection", () => {
        var _a, _b;
        const testSource = icsManager.getConfig().sources[0];
        // Add holiday configuration to source
        testSource.holidayConfig = {
            enabled: true,
            detectionPatterns: {
                summary: ["Holiday", "Festival"],
                categories: ["holiday"],
            },
            groupingStrategy: "summary",
            maxGapDays: 1,
            showInForecast: true,
            showInCalendar: true,
        };
        const icsData = `BEGIN:VCALENDAR
VERSION:2.0
PRODID:-//Test//Holiday Test//EN
BEGIN:VEVENT
UID:holiday-event@example.com
DTSTART:20240315T120000Z
DTEND:20240315T130000Z
SUMMARY:Spring Festival Holiday
DESCRIPTION:Traditional spring festival celebration
CATEGORIES:holiday
STATUS:CONFIRMED
END:VEVENT
END:VCALENDAR`;
        const parseResult = IcsParser.parse(icsData, testSource);
        expect(parseResult.events).toHaveLength(1);
        // Test holiday detection directly on events
        const events = parseResult.events;
        const eventsWithHoliday = icsManager.convertEventsWithHolidayToTasks(events.map(event => (Object.assign(Object.assign({}, event), { isHoliday: true, showInForecast: true }))));
        expect(eventsWithHoliday).toHaveLength(1);
        const task = eventsWithHoliday[0];
        const metadata = task.metadata;
        // Should still have time components despite holiday processing
        expect(metadata.timeComponents).toBeDefined();
        expect((_a = metadata.timeComponents) === null || _a === void 0 ? void 0 : _a.startTime).toBeDefined();
        expect((_b = metadata.timeComponents) === null || _b === void 0 ? void 0 : _b.endTime).toBeDefined();
        expect(metadata.enhancedDates).toBeDefined();
    });
    test("error handling in time component extraction", () => {
        const testSource = icsManager.getConfig().sources[0];
        // ICS data with potential parsing issues
        const icsData = `BEGIN:VCALENDAR
VERSION:2.0
PRODID:-//Test//Error Test//EN
BEGIN:VEVENT
UID:problematic-event@example.com
DTSTART;VALUE=DATE:20240315
SUMMARY:Problematic Event
DESCRIPTION:Event with invalid time format: 25:99 and other text
LOCATION:Somewhere
STATUS:CONFIRMED
END:VEVENT
END:VCALENDAR`;
        const parseResult = IcsParser.parse(icsData, testSource);
        expect(parseResult.events).toHaveLength(1);
        // Should not throw error during conversion
        expect(() => {
            const tasks = icsManager.convertEventsToTasks(parseResult.events);
            expect(tasks).toHaveLength(1);
            const task = tasks[0];
            expect(task.content).toBe("Problematic Event");
            // Should handle gracefully - may or may not have time components
            // but should not crash
            const metadata = task.metadata;
            expect(metadata).toBeDefined();
        }).not.toThrow();
    });
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSWNzRXZlbnRUaW1lSGFuZGxpbmcuaW50ZWdyYXRpb24udGVzdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIkljc0V2ZW50VGltZUhhbmRsaW5nLmludGVncmF0aW9uLnRlc3QudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7OztHQUdHO0FBRUgsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBQ3JELE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLGtDQUFrQyxDQUFDO0FBQ3RFLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUlsRCwwQkFBMEI7QUFDMUIsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQztJQUM1QixTQUFTLEVBQUUsTUFBTSxhQUFhO1FBQzdCLGdCQUFlLENBQUM7UUFDaEIsSUFBSSxLQUFJLENBQUM7UUFDVCxNQUFNLEtBQUksQ0FBQztRQUNYLE1BQU0sS0FBSSxDQUFDO1FBQ1gsUUFBUSxLQUFJLENBQUM7UUFDYixRQUFRLEtBQUksQ0FBQztRQUNiLFdBQVcsS0FBSSxDQUFDO1FBQ2hCLFFBQVEsS0FBSSxDQUFDO0tBQ2I7SUFDRCxVQUFVLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRTtDQUNyQixDQUFDLENBQUMsQ0FBQztBQUVKLG9DQUFvQztBQUNwQyxNQUFNLGtCQUFrQixHQUFHO0lBQzFCLGVBQWUsRUFBRTtRQUNoQixhQUFhLEVBQUUsR0FBRztRQUNsQixhQUFhLEVBQUUsR0FBRztRQUNsQixTQUFTLEVBQUUsR0FBRztRQUNkLFNBQVMsRUFBRSxHQUFHO1FBQ2QsT0FBTyxFQUFFLEdBQUc7S0FDWjtDQUNNLENBQUM7QUFFVCwyQkFBMkI7QUFDM0IsTUFBTSxxQkFBcUIsR0FBRztJQUM3QixPQUFPLEVBQUUsSUFBSTtJQUNiLGtCQUFrQixFQUFFLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQztJQUNoQyxZQUFZLEVBQUU7UUFD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SUFBSSxDQUFDLDZDQUE2QyxFQUFFLEdBQUcsRUFBRTtRQUN4RCxNQUFNLFVBQVUsR0FBRyxVQUFVLENBQUMsU0FBUyxFQUFFLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRXJELHlDQUF5QztRQUN6QyxNQUFNLE9BQU8sR0FBRzs7Ozs7Ozs7Ozs7Y0FXSixDQUFDO1FBRWIsTUFBTSxXQUFXLEdBQUcsU0FBUyxDQUFDLEtBQUssQ0FBQyxPQUFPLEVBQUUsVUFBVSxDQUFDLENBQUM7UUFDekQsTUFBTSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFFM0MsMkNBQTJDO1FBQzNDLE1BQU0sQ0FBQyxHQUFHLEVBQUU7WUFDWCxNQUFNLEtBQUssR0FBRyxVQUFVLENBQUMsb0JBQW9CLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQ2xFLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFFOUIsTUFBTSxJQUFJLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3RCLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDLG1CQUFtQixDQUFDLENBQUM7WUFFL0MsaUVBQWlFO1lBQ2pFLHVCQUF1QjtZQUN2QixNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsUUFBd0MsQ0FBQztZQUMvRCxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUM7UUFDaEMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLE9BQU8sRUFBRSxDQUFDO0lBQ2xCLENBQUMsQ0FBQyxDQUFDO0FBQ0osQ0FBQyxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogSUNTIEV2ZW50IFRpbWUgSGFuZGxpbmcgSW50ZWdyYXRpb24gVGVzdFxyXG4gKiBFbmQtdG8tZW5kIHRlc3QgZm9yIElDUyBldmVudCB0aW1lIHByZXNlcnZhdGlvbiBhbmQgZW5oYW5jZWQgcGFyc2luZ1xyXG4gKi9cclxuXHJcbmltcG9ydCB7IEljc01hbmFnZXIgfSBmcm9tIFwiLi4vbWFuYWdlcnMvaWNzLW1hbmFnZXJcIjtcclxuaW1wb3J0IHsgVGltZVBhcnNpbmdTZXJ2aWNlIH0gZnJvbSBcIi4uL3NlcnZpY2VzL3RpbWUtcGFyc2luZy1zZXJ2aWNlXCI7XHJcbmltcG9ydCB7IEljc1BhcnNlciB9IGZyb20gXCIuLi9wYXJzZXJzL2ljcy1wYXJzZXJcIjtcclxuaW1wb3J0IHsgSWNzU291cmNlLCBJY3NNYW5hZ2VyQ29uZmlnIH0gZnJvbSBcIi4uL3R5cGVzL2ljc1wiO1xyXG5pbXBvcnQgeyBFbmhhbmNlZFN0YW5kYXJkVGFza01ldGFkYXRhIH0gZnJvbSBcIi4uL3R5cGVzL3RpbWUtcGFyc2luZ1wiO1xyXG5cclxuLy8gTW9jayBPYnNpZGlhbiBDb21wb25lbnRcclxuamVzdC5tb2NrKFwib2JzaWRpYW5cIiwgKCkgPT4gKHtcclxuXHRDb21wb25lbnQ6IGNsYXNzIE1vY2tDb21wb25lbnQge1xyXG5cdFx0Y29uc3RydWN0b3IoKSB7fVxyXG5cdFx0bG9hZCgpIHt9XHJcblx0XHR1bmxvYWQoKSB7fVxyXG5cdFx0b25sb2FkKCkge31cclxuXHRcdG9udW5sb2FkKCkge31cclxuXHRcdGFkZENoaWxkKCkge31cclxuXHRcdHJlbW92ZUNoaWxkKCkge31cclxuXHRcdHJlZ2lzdGVyKCkge31cclxuXHR9LFxyXG5cdHJlcXVlc3RVcmw6IGplc3QuZm4oKSxcclxufSkpO1xyXG5cclxuLy8gTW9jayBtaW5pbWFsIHNldHRpbmdzIGZvciB0ZXN0aW5nXHJcbmNvbnN0IG1vY2tQbHVnaW5TZXR0aW5ncyA9IHtcclxuXHR0YXNrU3RhdHVzTWFya3M6IHtcclxuXHRcdFwiTm90IFN0YXJ0ZWRcIjogXCIgXCIsXHJcblx0XHRcIkluIFByb2dyZXNzXCI6IFwiL1wiLFxyXG5cdFx0Q29tcGxldGVkOiBcInhcIixcclxuXHRcdEFiYW5kb25lZDogXCItXCIsXHJcblx0XHRQbGFubmVkOiBcIj9cIixcclxuXHR9LFxyXG59IGFzIGFueTtcclxuXHJcbi8vIE1vY2sgdGltZSBwYXJzaW5nIGNvbmZpZ1xyXG5jb25zdCBtb2NrVGltZVBhcnNpbmdDb25maWcgPSB7XHJcblx0ZW5hYmxlZDogdHJ1ZSxcclxuXHRzdXBwb3J0ZWRMYW5ndWFnZXM6IFtcImVuXCIsIFwiemhcIl0sXHJcblx0ZGF0ZUtleXdvcmRzOiB7XHJcblx0XHRzdGFydDogW1wic3RhcnRcIiwgXCJmcm9tXCIsIFwiYmVnaW5zXCJdLFxyXG5cdFx0ZHVlOiBbXCJkdWVcIiwgXCJieVwiLCBcInVudGlsXCJdLFxyXG5cdFx0c2NoZWR1bGVkOiBbXCJhdFwiLCBcIm9uXCIsIFwic2NoZWR1bGVkXCJdLFxyXG5cdH0sXHJcblx0cmVtb3ZlT3JpZ2luYWxUZXh0OiBmYWxzZSxcclxuXHRwZXJMaW5lUHJvY2Vzc2luZzogdHJ1ZSxcclxuXHRyZWFsVGltZVJlcGxhY2VtZW50OiBmYWxzZSxcclxufTtcclxuXHJcbmRlc2NyaWJlKFwiSUNTIEV2ZW50IFRpbWUgSGFuZGxpbmcgSW50ZWdyYXRpb25cIiwgKCkgPT4ge1xyXG5cdGxldCBpY3NNYW5hZ2VyOiBJY3NNYW5hZ2VyO1xyXG5cdGxldCB0aW1lUGFyc2luZ1NlcnZpY2U6IFRpbWVQYXJzaW5nU2VydmljZTtcclxuXHJcblx0YmVmb3JlRWFjaCgoKSA9PiB7XHJcblx0XHR0aW1lUGFyc2luZ1NlcnZpY2UgPSBuZXcgVGltZVBhcnNpbmdTZXJ2aWNlKG1vY2tUaW1lUGFyc2luZ0NvbmZpZyk7XHJcblx0XHRcclxuXHRcdGNvbnN0IHRlc3RTb3VyY2U6IEljc1NvdXJjZSA9IHtcclxuXHRcdFx0aWQ6IFwiaW50ZWdyYXRpb24tdGVzdFwiLFxyXG5cdFx0XHRuYW1lOiBcIkludGVncmF0aW9uIFRlc3QgQ2FsZW5kYXJcIixcclxuXHRcdFx0dXJsOiBcImh0dHBzOi8vZXhhbXBsZS5jb20vdGVzdC5pY3NcIixcclxuXHRcdFx0ZW5hYmxlZDogdHJ1ZSxcclxuXHRcdFx0cmVmcmVzaEludGVydmFsOiA2MCxcclxuXHRcdFx0c2hvd0FsbERheUV2ZW50czogdHJ1ZSxcclxuXHRcdFx0c2hvd1RpbWVkRXZlbnRzOiB0cnVlLFxyXG5cdFx0XHRzaG93VHlwZTogXCJldmVudFwiLFxyXG5cdFx0fTtcclxuXHJcblx0XHRjb25zdCBtb2NrQ29uZmlnOiBJY3NNYW5hZ2VyQ29uZmlnID0ge1xyXG5cdFx0XHRzb3VyY2VzOiBbdGVzdFNvdXJjZV0sXHJcblx0XHRcdGdsb2JhbFJlZnJlc2hJbnRlcnZhbDogNjAsXHJcblx0XHRcdG1heENhY2hlQWdlOiAyNCxcclxuXHRcdFx0ZW5hYmxlQmFja2dyb3VuZFJlZnJlc2g6IGZhbHNlLFxyXG5cdFx0XHRuZXR3b3JrVGltZW91dDogMzAsXHJcblx0XHRcdG1heEV2ZW50c1BlclNvdXJjZTogMTAwMCxcclxuXHRcdFx0c2hvd0luQ2FsZW5kYXI6IHRydWUsXHJcblx0XHRcdHNob3dJblRhc2tMaXN0czogdHJ1ZSxcclxuXHRcdFx0ZGVmYXVsdEV2ZW50Q29sb3I6IFwiIzM0OThkYlwiLFxyXG5cdFx0fTtcclxuXHJcblx0XHRpY3NNYW5hZ2VyID0gbmV3IEljc01hbmFnZXIobW9ja0NvbmZpZywgbW9ja1BsdWdpblNldHRpbmdzLCB1bmRlZmluZWQsIHRpbWVQYXJzaW5nU2VydmljZSk7XHJcblx0fSk7XHJcblxyXG5cdHRlc3QoXCJlbmQtdG8tZW5kIElDUyBldmVudCB3aXRoIHRpbWUgY29tcG9uZW50cyBjb252ZXJzaW9uXCIsICgpID0+IHtcclxuXHRcdC8vIFJlYWwtd29ybGQgSUNTIGRhdGEgd2l0aCB2YXJpb3VzIHRpbWUgZm9ybWF0c1xyXG5cdFx0Y29uc3QgaWNzRGF0YSA9IGBCRUdJTjpWQ0FMRU5EQVJcclxuVkVSU0lPTjoyLjBcclxuUFJPRElEOi0vL1Rlc3QvL0ludGVncmF0aW9uIFRlc3QvL0VOXHJcbkNBTFNDQUxFOkdSRUdPUklBTlxyXG5CRUdJTjpWRVZFTlRcclxuVUlEOm1lZXRpbmctd2l0aC10aW1lQGV4YW1wbGUuY29tXHJcbkRUU1RBUlQ6MjAyNDAzMTVUMDkzMDAwWlxyXG5EVEVORDoyMDI0MDMxNVQxMDMwMDBaXHJcblNVTU1BUlk6VGVhbSBTdGFuZHVwXHJcbkRFU0NSSVBUSU9OOkRhaWx5IHN0YW5kdXAgbWVldGluZyBmb3IgdGhlIGRldmVsb3BtZW50IHRlYW1cclxuTE9DQVRJT046Q29uZmVyZW5jZSBSb29tIEFcclxuU1RBVFVTOkNPTkZJUk1FRFxyXG5FTkQ6VkVWRU5UXHJcbkJFR0lOOlZFVkVOVFxyXG5VSUQ6d29ya3Nob3AtYWxsZGF5QGV4YW1wbGUuY29tXHJcbkRUU1RBUlQ7VkFMVUU9REFURToyMDI0MDMxNlxyXG5EVEVORDtWQUxVRT1EQVRFOjIwMjQwMzE3XHJcblNVTU1BUlk6V29ya3Nob3AgRGF5XHJcbkRFU0NSSVBUSU9OOkZ1bGwtZGF5IHdvcmtzaG9wIGZyb20gOTowMCBBTSB0byA1OjAwIFBNIHdpdGggbHVuY2ggYnJlYWsgYXQgMTI6MDAtMTM6MDBcclxuTE9DQVRJT046VHJhaW5pbmcgQ2VudGVyXHJcblNUQVRVUzpDT05GSVJNRURcclxuRU5EOlZFVkVOVFxyXG5CRUdJTjpWRVZFTlRcclxuVUlEOmRpbm5lci1ldmVudEBleGFtcGxlLmNvbVxyXG5EVFNUQVJUO1ZBTFVFPURBVEU6MjAyNDAzMTdcclxuU1VNTUFSWTpUZWFtIERpbm5lclxyXG5ERVNDUklQVElPTjpUZWFtIGRpbm5lciBhdCB0aGUgcmVzdGF1cmFudFxyXG5MT0NBVElPTjpJdGFsaWFuIFJlc3RhdXJhbnQgYXQgNzozMCBQTVxyXG5TVEFUVVM6Q09ORklSTUVEXHJcbkVORDpWRVZFTlRcclxuRU5EOlZDQUxFTkRBUmA7XHJcblxyXG5cdFx0Ly8gUGFyc2UgSUNTIGRhdGFcclxuXHRcdGNvbnN0IHRlc3RTb3VyY2UgPSBpY3NNYW5hZ2VyLmdldENvbmZpZygpLnNvdXJjZXNbMF07XHJcblx0XHRjb25zdCBwYXJzZVJlc3VsdCA9IEljc1BhcnNlci5wYXJzZShpY3NEYXRhLCB0ZXN0U291cmNlKTtcclxuXHRcdFxyXG5cdFx0ZXhwZWN0KHBhcnNlUmVzdWx0LmV2ZW50cykudG9IYXZlTGVuZ3RoKDMpO1xyXG5cdFx0ZXhwZWN0KHBhcnNlUmVzdWx0LmVycm9ycykudG9IYXZlTGVuZ3RoKDApO1xyXG5cclxuXHRcdC8vIENvbnZlcnQgdG8gdGFza3NcclxuXHRcdGNvbnN0IHRhc2tzID0gaWNzTWFuYWdlci5jb252ZXJ0RXZlbnRzVG9UYXNrcyhwYXJzZVJlc3VsdC5ldmVudHMpO1xyXG5cdFx0ZXhwZWN0KHRhc2tzKS50b0hhdmVMZW5ndGgoMyk7XHJcblxyXG5cdFx0Ly8gVGVzdCAxOiBUaW1lZCBldmVudCB3aXRoIElDUyB0aW1lIGNvbXBvbmVudHNcclxuXHRcdGNvbnN0IHRpbWVkVGFzayA9IHRhc2tzLmZpbmQodCA9PiB0LmNvbnRlbnQgPT09IFwiVGVhbSBTdGFuZHVwXCIpO1xyXG5cdFx0ZXhwZWN0KHRpbWVkVGFzaykudG9CZURlZmluZWQoKTtcclxuXHRcdFxyXG5cdFx0Y29uc3QgdGltZWRNZXRhZGF0YSA9IHRpbWVkVGFzayEubWV0YWRhdGEgYXMgRW5oYW5jZWRTdGFuZGFyZFRhc2tNZXRhZGF0YTtcclxuXHRcdGV4cGVjdCh0aW1lZE1ldGFkYXRhLnRpbWVDb21wb25lbnRzKS50b0JlRGVmaW5lZCgpO1xyXG5cdFx0ZXhwZWN0KHRpbWVkTWV0YWRhdGEudGltZUNvbXBvbmVudHM/LnN0YXJ0VGltZSkudG9CZURlZmluZWQoKTtcclxuXHRcdGV4cGVjdCh0aW1lZE1ldGFkYXRhLnRpbWVDb21wb25lbnRzPy5lbmRUaW1lKS50b0JlRGVmaW5lZCgpO1xyXG5cdFx0ZXhwZWN0KHRpbWVkTWV0YWRhdGEuZW5oYW5jZWREYXRlcykudG9CZURlZmluZWQoKTtcclxuXHRcdGV4cGVjdCh0aW1lZE1ldGFkYXRhLmVuaGFuY2VkRGF0ZXM/LnN0YXJ0RGF0ZVRpbWUpLnRvQmVEZWZpbmVkKCk7XHJcblx0XHRleHBlY3QodGltZWRNZXRhZGF0YS5lbmhhbmNlZERhdGVzPy5lbmREYXRlVGltZSkudG9CZURlZmluZWQoKTtcclxuXHJcblx0XHQvLyBUZXN0IDI6IEFsbC1kYXkgZXZlbnQgd2l0aCB0aW1lIHBhcnNpbmcgZnJvbSBkZXNjcmlwdGlvblxyXG5cdFx0Y29uc3Qgd29ya3Nob3BUYXNrID0gdGFza3MuZmluZCh0ID0+IHQuY29udGVudCA9PT0gXCJXb3Jrc2hvcCBEYXlcIik7XHJcblx0XHRleHBlY3Qod29ya3Nob3BUYXNrKS50b0JlRGVmaW5lZCgpO1xyXG5cdFx0XHJcblx0XHRjb25zdCB3b3Jrc2hvcE1ldGFkYXRhID0gd29ya3Nob3BUYXNrIS5tZXRhZGF0YSBhcyBFbmhhbmNlZFN0YW5kYXJkVGFza01ldGFkYXRhO1xyXG5cdFx0Ly8gU2hvdWxkIGhhdmUgdGltZSBjb21wb25lbnRzIHBhcnNlZCBmcm9tIGRlc2NyaXB0aW9uXHJcblx0XHRleHBlY3Qod29ya3Nob3BNZXRhZGF0YS50aW1lQ29tcG9uZW50cykudG9CZURlZmluZWQoKTtcclxuXHRcdGV4cGVjdCh3b3Jrc2hvcE1ldGFkYXRhLmVuaGFuY2VkRGF0ZXMpLnRvQmVEZWZpbmVkKCk7XHJcblxyXG5cdFx0Ly8gVGVzdCAzOiBFdmVudCB3aXRoIHRpbWUgaW4gbG9jYXRpb24gZmllbGRcclxuXHRcdGNvbnN0IGRpbm5lclRhc2sgPSB0YXNrcy5maW5kKHQgPT4gdC5jb250ZW50ID09PSBcIlRlYW0gRGlubmVyXCIpO1xyXG5cdFx0ZXhwZWN0KGRpbm5lclRhc2spLnRvQmVEZWZpbmVkKCk7XHJcblx0XHRcclxuXHRcdGNvbnN0IGRpbm5lck1ldGFkYXRhID0gZGlubmVyVGFzayEubWV0YWRhdGEgYXMgRW5oYW5jZWRTdGFuZGFyZFRhc2tNZXRhZGF0YTtcclxuXHRcdC8vIFNob3VsZCBoYXZlIHRpbWUgY29tcG9uZW50cyBwYXJzZWQgZnJvbSBsb2NhdGlvblxyXG5cdFx0ZXhwZWN0KGRpbm5lck1ldGFkYXRhLnRpbWVDb21wb25lbnRzKS50b0JlRGVmaW5lZCgpO1xyXG5cdFx0ZXhwZWN0KGRpbm5lck1ldGFkYXRhLmVuaGFuY2VkRGF0ZXMpLnRvQmVEZWZpbmVkKCk7XHJcblxyXG5cdFx0Ly8gVmVyaWZ5IGFsbCB0YXNrcyBtYWludGFpbiBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XHJcblx0XHRmb3IgKGNvbnN0IHRhc2sgb2YgdGFza3MpIHtcclxuXHRcdFx0ZXhwZWN0KHRhc2suaWQpLnRvQmVEZWZpbmVkKCk7XHJcblx0XHRcdGV4cGVjdCh0YXNrLmNvbnRlbnQpLnRvQmVEZWZpbmVkKCk7XHJcblx0XHRcdGV4cGVjdCh0YXNrLmZpbGVQYXRoKS50b0JlKFwiaWNzOi8vSW50ZWdyYXRpb24gVGVzdCBDYWxlbmRhclwiKTtcclxuXHRcdFx0ZXhwZWN0KHRhc2suaWNzRXZlbnQpLnRvQmVEZWZpbmVkKCk7XHJcblx0XHRcdGV4cGVjdCh0YXNrLnJlYWRvbmx5KS50b0JlKHRydWUpO1xyXG5cdFx0XHRleHBlY3QodGFzay5zb3VyY2UudHlwZSkudG9CZShcImljc1wiKTtcclxuXHRcdFx0ZXhwZWN0KHRhc2subWV0YWRhdGEuc3RhcnREYXRlKS50b0JlRGVmaW5lZCgpO1xyXG5cdFx0XHRleHBlY3QodGFzay5tZXRhZGF0YS5wcm9qZWN0KS50b0JlKFwiSW50ZWdyYXRpb24gVGVzdCBDYWxlbmRhclwiKTtcclxuXHRcdH1cclxuXHR9KTtcclxuXHJcblx0dGVzdChcIklDUyBldmVudCB0aW1lIHByZXNlcnZhdGlvbiB3aXRoIGhvbGlkYXkgZGV0ZWN0aW9uXCIsICgpID0+IHtcclxuXHRcdGNvbnN0IHRlc3RTb3VyY2UgPSBpY3NNYW5hZ2VyLmdldENvbmZpZygpLnNvdXJjZXNbMF07XHJcblx0XHRcclxuXHRcdC8vIEFkZCBob2xpZGF5IGNvbmZpZ3VyYXRpb24gdG8gc291cmNlXHJcblx0XHR0ZXN0U291cmNlLmhvbGlkYXlDb25maWcgPSB7XHJcblx0XHRcdGVuYWJsZWQ6IHRydWUsXHJcblx0XHRcdGRldGVjdGlvblBhdHRlcm5zOiB7XHJcblx0XHRcdFx0c3VtbWFyeTogW1wiSG9saWRheVwiLCBcIkZlc3RpdmFsXCJdLFxyXG5cdFx0XHRcdGNhdGVnb3JpZXM6IFtcImhvbGlkYXlcIl0sXHJcblx0XHRcdH0sXHJcblx0XHRcdGdyb3VwaW5nU3RyYXRlZ3k6IFwic3VtbWFyeVwiLFxyXG5cdFx0XHRtYXhHYXBEYXlzOiAxLFxyXG5cdFx0XHRzaG93SW5Gb3JlY2FzdDogdHJ1ZSxcclxuXHRcdFx0c2hvd0luQ2FsZW5kYXI6IHRydWUsXHJcblx0XHR9O1xyXG5cclxuXHRcdGNvbnN0IGljc0RhdGEgPSBgQkVHSU46VkNBTEVOREFSXHJcblZFUlNJT046Mi4wXHJcblBST0RJRDotLy9UZXN0Ly9Ib2xpZGF5IFRlc3QvL0VOXHJcbkJFR0lOOlZFVkVOVFxyXG5VSUQ6aG9saWRheS1ldmVudEBleGFtcGxlLmNvbVxyXG5EVFNUQVJUOjIwMjQwMzE1VDEyMDAwMFpcclxuRFRFTkQ6MjAyNDAzMTVUMTMwMDAwWlxyXG5TVU1NQVJZOlNwcmluZyBGZXN0aXZhbCBIb2xpZGF5XHJcbkRFU0NSSVBUSU9OOlRyYWRpdGlvbmFsIHNwcmluZyBmZXN0aXZhbCBjZWxlYnJhdGlvblxyXG5DQVRFR09SSUVTOmhvbGlkYXlcclxuU1RBVFVTOkNPTkZJUk1FRFxyXG5FTkQ6VkVWRU5UXHJcbkVORDpWQ0FMRU5EQVJgO1xyXG5cclxuXHRcdGNvbnN0IHBhcnNlUmVzdWx0ID0gSWNzUGFyc2VyLnBhcnNlKGljc0RhdGEsIHRlc3RTb3VyY2UpO1xyXG5cdFx0ZXhwZWN0KHBhcnNlUmVzdWx0LmV2ZW50cykudG9IYXZlTGVuZ3RoKDEpO1xyXG5cclxuXHRcdC8vIFRlc3QgaG9saWRheSBkZXRlY3Rpb24gZGlyZWN0bHkgb24gZXZlbnRzXHJcblx0XHRjb25zdCBldmVudHMgPSBwYXJzZVJlc3VsdC5ldmVudHM7XHJcblx0XHRjb25zdCBldmVudHNXaXRoSG9saWRheSA9IGljc01hbmFnZXIuY29udmVydEV2ZW50c1dpdGhIb2xpZGF5VG9UYXNrcyhcclxuXHRcdFx0ZXZlbnRzLm1hcChldmVudCA9PiAoe1xyXG5cdFx0XHRcdC4uLmV2ZW50LFxyXG5cdFx0XHRcdGlzSG9saWRheTogdHJ1ZSwgLy8gU2ltdWxhdGUgaG9saWRheSBkZXRlY3Rpb25cclxuXHRcdFx0XHRzaG93SW5Gb3JlY2FzdDogdHJ1ZSxcclxuXHRcdFx0fSkpXHJcblx0XHQpO1xyXG5cdFx0ZXhwZWN0KGV2ZW50c1dpdGhIb2xpZGF5KS50b0hhdmVMZW5ndGgoMSk7XHJcblxyXG5cdFx0Y29uc3QgdGFzayA9IGV2ZW50c1dpdGhIb2xpZGF5WzBdO1xyXG5cdFx0Y29uc3QgbWV0YWRhdGEgPSB0YXNrLm1ldGFkYXRhIGFzIEVuaGFuY2VkU3RhbmRhcmRUYXNrTWV0YWRhdGE7XHJcblx0XHRcclxuXHRcdC8vIFNob3VsZCBzdGlsbCBoYXZlIHRpbWUgY29tcG9uZW50cyBkZXNwaXRlIGhvbGlkYXkgcHJvY2Vzc2luZ1xyXG5cdFx0ZXhwZWN0KG1ldGFkYXRhLnRpbWVDb21wb25lbnRzKS50b0JlRGVmaW5lZCgpO1xyXG5cdFx0ZXhwZWN0KG1ldGFkYXRhLnRpbWVDb21wb25lbnRzPy5zdGFydFRpbWUpLnRvQmVEZWZpbmVkKCk7XHJcblx0XHRleHBlY3QobWV0YWRhdGEudGltZUNvbXBvbmVudHM/LmVuZFRpbWUpLnRvQmVEZWZpbmVkKCk7XHJcblx0XHRleHBlY3QobWV0YWRhdGEuZW5oYW5jZWREYXRlcykudG9CZURlZmluZWQoKTtcclxuXHR9KTtcclxuXHJcblx0dGVzdChcImVycm9yIGhhbmRsaW5nIGluIHRpbWUgY29tcG9uZW50IGV4dHJhY3Rpb25cIiwgKCkgPT4ge1xyXG5cdFx0Y29uc3QgdGVzdFNvdXJjZSA9IGljc01hbmFnZXIuZ2V0Q29uZmlnKCkuc291cmNlc1swXTtcclxuXHJcblx0XHQvLyBJQ1MgZGF0YSB3aXRoIHBvdGVudGlhbCBwYXJzaW5nIGlzc3Vlc1xyXG5cdFx0Y29uc3QgaWNzRGF0YSA9IGBCRUdJTjpWQ0FMRU5EQVJcclxuVkVSU0lPTjoyLjBcclxuUFJPRElEOi0vL1Rlc3QvL0Vycm9yIFRlc3QvL0VOXHJcbkJFR0lOOlZFVkVOVFxyXG5VSUQ6cHJvYmxlbWF0aWMtZXZlbnRAZXhhbXBsZS5jb21cclxuRFRTVEFSVDtWQUxVRT1EQVRFOjIwMjQwMzE1XHJcblNVTU1BUlk6UHJvYmxlbWF0aWMgRXZlbnRcclxuREVTQ1JJUFRJT046RXZlbnQgd2l0aCBpbnZhbGlkIHRpbWUgZm9ybWF0OiAyNTo5OSBhbmQgb3RoZXIgdGV4dFxyXG5MT0NBVElPTjpTb21ld2hlcmVcclxuU1RBVFVTOkNPTkZJUk1FRFxyXG5FTkQ6VkVWRU5UXHJcbkVORDpWQ0FMRU5EQVJgO1xyXG5cclxuXHRcdGNvbnN0IHBhcnNlUmVzdWx0ID0gSWNzUGFyc2VyLnBhcnNlKGljc0RhdGEsIHRlc3RTb3VyY2UpO1xyXG5cdFx0ZXhwZWN0KHBhcnNlUmVzdWx0LmV2ZW50cykudG9IYXZlTGVuZ3RoKDEpO1xyXG5cclxuXHRcdC8vIFNob3VsZCBub3QgdGhyb3cgZXJyb3IgZHVyaW5nIGNvbnZlcnNpb25cclxuXHRcdGV4cGVjdCgoKSA9PiB7XHJcblx0XHRcdGNvbnN0IHRhc2tzID0gaWNzTWFuYWdlci5jb252ZXJ0RXZlbnRzVG9UYXNrcyhwYXJzZVJlc3VsdC5ldmVudHMpO1xyXG5cdFx0XHRleHBlY3QodGFza3MpLnRvSGF2ZUxlbmd0aCgxKTtcclxuXHRcdFx0XHJcblx0XHRcdGNvbnN0IHRhc2sgPSB0YXNrc1swXTtcclxuXHRcdFx0ZXhwZWN0KHRhc2suY29udGVudCkudG9CZShcIlByb2JsZW1hdGljIEV2ZW50XCIpO1xyXG5cdFx0XHRcclxuXHRcdFx0Ly8gU2hvdWxkIGhhbmRsZSBncmFjZWZ1bGx5IC0gbWF5IG9yIG1heSBub3QgaGF2ZSB0aW1lIGNvbXBvbmVudHNcclxuXHRcdFx0Ly8gYnV0IHNob3VsZCBub3QgY3Jhc2hcclxuXHRcdFx0Y29uc3QgbWV0YWRhdGEgPSB0YXNrLm1ldGFkYXRhIGFzIEVuaGFuY2VkU3RhbmRhcmRUYXNrTWV0YWRhdGE7XHJcblx0XHRcdGV4cGVjdChtZXRhZGF0YSkudG9CZURlZmluZWQoKTtcclxuXHRcdH0pLm5vdC50b1Rocm93KCk7XHJcblx0fSk7XHJcbn0pOyJdfQ==