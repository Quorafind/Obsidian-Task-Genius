/**
 * Tests for date display helper functions
 * Ensures correct conversion between UTC noon timestamps and local date display
 */
import { timestampToLocalDateString, localDateStringToTimestamp } from "@/utils/date/date-display-helper";
describe("Date Display Helper", () => {
    describe("timestampToLocalDateString", () => {
        it("should convert UTC noon timestamp to correct local date string", () => {
            // Test date: 2025-09-01 stored as UTC noon
            const utcNoonTimestamp = new Date(Date.UTC(2025, 8, 1, 12, 0, 0)).getTime();
            // The result should always be 2025-09-01 regardless of timezone
            const result = timestampToLocalDateString(utcNoonTimestamp);
            expect(result).toBe("2025-09-01");
        });
        it("should handle undefined timestamp", () => {
            const result = timestampToLocalDateString(undefined);
            expect(result).toBe("");
        });
        it("should handle dates at year boundaries", () => {
            // Test date: 2024-12-31 stored as UTC noon
            const utcNoonTimestamp = new Date(Date.UTC(2024, 11, 31, 12, 0, 0)).getTime();
            const result = timestampToLocalDateString(utcNoonTimestamp);
            expect(result).toBe("2024-12-31");
        });
        it("should handle leap year date", () => {
            // Test date: 2024-02-29 (leap year) stored as UTC noon
            const utcNoonTimestamp = new Date(Date.UTC(2024, 1, 29, 12, 0, 0)).getTime();
            const result = timestampToLocalDateString(utcNoonTimestamp);
            expect(result).toBe("2024-02-29");
        });
    });
    describe("localDateStringToTimestamp", () => {
        it("should convert local date string to UTC noon timestamp", () => {
            const dateString = "2025-09-01";
            const result = localDateStringToTimestamp(dateString);
            // Should be UTC noon for the given date
            const expected = new Date(Date.UTC(2025, 8, 1, 12, 0, 0)).getTime();
            expect(result).toBe(expected);
        });
        it("should handle undefined date string", () => {
            const result = localDateStringToTimestamp("");
            expect(result).toBeUndefined();
        });
        it("should handle invalid date string", () => {
            const result = localDateStringToTimestamp("invalid-date");
            expect(result).toBeUndefined();
        });
        it("should handle dates at year boundaries", () => {
            const dateString = "2024-12-31";
            const result = localDateStringToTimestamp(dateString);
            const expected = new Date(Date.UTC(2024, 11, 31, 12, 0, 0)).getTime();
            expect(result).toBe(expected);
        });
    });
    describe("Round-trip conversion", () => {
        it("should maintain date integrity through round-trip conversion", () => {
            const testDates = [
                "2025-09-01",
                "2024-12-31",
                "2025-01-01",
                "2024-02-29",
                "2025-06-15",
            ];
            for (const originalDate of testDates) {
                const timestamp = localDateStringToTimestamp(originalDate);
                const convertedBack = timestampToLocalDateString(timestamp);
                expect(convertedBack).toBe(originalDate);
            }
        });
    });
    describe("Timezone edge cases", () => {
        it("should handle dates correctly even when local time would be different day", () => {
            // This simulates the issue where a date stored as UTC noon
            // might appear as a different day in certain timezones
            // Create a timestamp for 2025-09-01 at UTC noon
            const timestamp = new Date(Date.UTC(2025, 8, 1, 12, 0, 0)).getTime();
            // Even if the user is in a timezone where this would be 
            // 2025-09-01 19:00 (UTC+7) or 2025-09-01 08:00 (UTC-4),
            // the display should still show 2025-09-01
            const result = timestampToLocalDateString(timestamp);
            expect(result).toBe("2025-09-01");
        });
    });
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZS1kaXNwbGF5LWhlbHBlci50ZXN0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiZGF0ZS1kaXNwbGF5LWhlbHBlci50ZXN0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7R0FHRztBQUVILE9BQU8sRUFBRSwwQkFBMEIsRUFBRSwwQkFBMEIsRUFBRSxNQUFNLGtDQUFrQyxDQUFDO0FBRTFHLFFBQVEsQ0FBQyxxQkFBcUIsRUFBRSxHQUFHLEVBQUU7SUFDcEMsUUFBUSxDQUFDLDRCQUE0QixFQUFFLEdBQUcsRUFBRTtRQUMzQyxFQUFFLENBQUMsZ0VBQWdFLEVBQUUsR0FBRyxFQUFFO1lBQ3pFLDJDQUEyQztZQUMzQyxNQUFNLGdCQUFnQixHQUFHLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBRTVFLGdFQUFnRTtZQUNoRSxNQUFNLE1BQU0sR0FBRywwQkFBMEIsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO1lBQzVELE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7UUFDbkMsQ0FBQyxDQUFDLENBQUM7UUFFSCxFQUFFLENBQUMsbUNBQW1DLEVBQUUsR0FBRyxFQUFFO1lBQzVDLE1BQU0sTUFBTSxHQUFHLDBCQUEwQixDQUFDLFNBQVMsQ0FBQyxDQUFDO1lBQ3JELE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDekIsQ0FBQyxDQUFDLENBQUM7UUFFSCxFQUFFLENBQUMsd0NBQXdDLEVBQUUsR0FBRyxFQUFFO1lBQ2pELDJDQUEyQztZQUMzQyxNQUFNLGdCQUFnQixHQUFHLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxFQUFFLEVBQUUsRUFBRSxF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Q0FBQyxZQUFZLENBQUMsQ0FBQztnQkFDM0QsTUFBTSxhQUFhLEdBQUcsMEJBQTBCLENBQUMsU0FBUyxDQUFDLENBQUM7Z0JBQzVELE1BQU0sQ0FBQyxhQUFhLENBQUMsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7YUFDekM7UUFDRixDQUFDLENBQUMsQ0FBQztJQUNKLENBQUMsQ0FBQyxDQUFDO0lBRUgsUUFBUSxDQUFDLHFCQUFxQixFQUFFLEdBQUcsRUFBRTtRQUNwQyxFQUFFLENBQUMsMkVBQTJFLEVBQUUsR0FBRyxFQUFFO1lBQ3BGLDJEQUEyRDtZQUMzRCx1REFBdUQ7WUFFdkQsZ0RBQWdEO1lBQ2hELE1BQU0sU0FBUyxHQUFHLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBRXJFLHlEQUF5RDtZQUN6RCx3REFBd0Q7WUFDeEQsMkNBQTJDO1lBQzNDLE1BQU0sTUFBTSxHQUFHLDBCQUEwQixDQUFDLFNBQVMsQ0FBQyxDQUFDO1lBQ3JELE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7UUFDbkMsQ0FBQyxDQUFDLENBQUM7SUFDSixDQUFDLENBQUMsQ0FBQztBQUNKLENBQUMsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIFRlc3RzIGZvciBkYXRlIGRpc3BsYXkgaGVscGVyIGZ1bmN0aW9uc1xyXG4gKiBFbnN1cmVzIGNvcnJlY3QgY29udmVyc2lvbiBiZXR3ZWVuIFVUQyBub29uIHRpbWVzdGFtcHMgYW5kIGxvY2FsIGRhdGUgZGlzcGxheVxyXG4gKi9cclxuXHJcbmltcG9ydCB7IHRpbWVzdGFtcFRvTG9jYWxEYXRlU3RyaW5nLCBsb2NhbERhdGVTdHJpbmdUb1RpbWVzdGFtcCB9IGZyb20gXCJAL3V0aWxzL2RhdGUvZGF0ZS1kaXNwbGF5LWhlbHBlclwiO1xyXG5cclxuZGVzY3JpYmUoXCJEYXRlIERpc3BsYXkgSGVscGVyXCIsICgpID0+IHtcclxuXHRkZXNjcmliZShcInRpbWVzdGFtcFRvTG9jYWxEYXRlU3RyaW5nXCIsICgpID0+IHtcclxuXHRcdGl0KFwic2hvdWxkIGNvbnZlcnQgVVRDIG5vb24gdGltZXN0YW1wIHRvIGNvcnJlY3QgbG9jYWwgZGF0ZSBzdHJpbmdcIiwgKCkgPT4ge1xyXG5cdFx0XHQvLyBUZXN0IGRhdGU6IDIwMjUtMDktMDEgc3RvcmVkIGFzIFVUQyBub29uXHJcblx0XHRcdGNvbnN0IHV0Y05vb25UaW1lc3RhbXAgPSBuZXcgRGF0ZShEYXRlLlVUQygyMDI1LCA4LCAxLCAxMiwgMCwgMCkpLmdldFRpbWUoKTtcclxuXHRcdFx0XHJcblx0XHRcdC8vIFRoZSByZXN1bHQgc2hvdWxkIGFsd2F5cyBiZSAyMDI1LTA5LTAxIHJlZ2FyZGxlc3Mgb2YgdGltZXpvbmVcclxuXHRcdFx0Y29uc3QgcmVzdWx0ID0gdGltZXN0YW1wVG9Mb2NhbERhdGVTdHJpbmcodXRjTm9vblRpbWVzdGFtcCk7XHJcblx0XHRcdGV4cGVjdChyZXN1bHQpLnRvQmUoXCIyMDI1LTA5LTAxXCIpO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0aXQoXCJzaG91bGQgaGFuZGxlIHVuZGVmaW5lZCB0aW1lc3RhbXBcIiwgKCkgPT4ge1xyXG5cdFx0XHRjb25zdCByZXN1bHQgPSB0aW1lc3RhbXBUb0xvY2FsRGF0ZVN0cmluZyh1bmRlZmluZWQpO1xyXG5cdFx0XHRleHBlY3QocmVzdWx0KS50b0JlKFwiXCIpO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0aXQoXCJzaG91bGQgaGFuZGxlIGRhdGVzIGF0IHllYXIgYm91bmRhcmllc1wiLCAoKSA9PiB7XHJcblx0XHRcdC8vIFRlc3QgZGF0ZTogMjAyNC0xMi0zMSBzdG9yZWQgYXMgVVRDIG5vb25cclxuXHRcdFx0Y29uc3QgdXRjTm9vblRpbWVzdGFtcCA9IG5ldyBEYXRlKERhdGUuVVRDKDIwMjQsIDExLCAzMSwgMTIsIDAsIDApKS5nZXRUaW1lKCk7XHJcblx0XHRcdGNvbnN0IHJlc3VsdCA9IHRpbWVzdGFtcFRvTG9jYWxEYXRlU3RyaW5nKHV0Y05vb25UaW1lc3RhbXApO1xyXG5cdFx0XHRleHBlY3QocmVzdWx0KS50b0JlKFwiMjAyNC0xMi0zMVwiKTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdGl0KFwic2hvdWxkIGhhbmRsZSBsZWFwIHllYXIgZGF0ZVwiLCAoKSA9PiB7XHJcblx0XHRcdC8vIFRlc3QgZGF0ZTogMjAyNC0wMi0yOSAobGVhcCB5ZWFyKSBzdG9yZWQgYXMgVVRDIG5vb25cclxuXHRcdFx0Y29uc3QgdXRjTm9vblRpbWVzdGFtcCA9IG5ldyBEYXRlKERhdGUuVVRDKDIwMjQsIDEsIDI5LCAxMiwgMCwgMCkpLmdldFRpbWUoKTtcclxuXHRcdFx0Y29uc3QgcmVzdWx0ID0gdGltZXN0YW1wVG9Mb2NhbERhdGVTdHJpbmcodXRjTm9vblRpbWVzdGFtcCk7XHJcblx0XHRcdGV4cGVjdChyZXN1bHQpLnRvQmUoXCIyMDI0LTAyLTI5XCIpO1xyXG5cdFx0fSk7XHJcblx0fSk7XHJcblxyXG5cdGRlc2NyaWJlKFwibG9jYWxEYXRlU3RyaW5nVG9UaW1lc3RhbXBcIiwgKCkgPT4ge1xyXG5cdFx0aXQoXCJzaG91bGQgY29udmVydCBsb2NhbCBkYXRlIHN0cmluZyB0byBVVEMgbm9vbiB0aW1lc3RhbXBcIiwgKCkgPT4ge1xyXG5cdFx0XHRjb25zdCBkYXRlU3RyaW5nID0gXCIyMDI1LTA5LTAxXCI7XHJcblx0XHRcdGNvbnN0IHJlc3VsdCA9IGxvY2FsRGF0ZVN0cmluZ1RvVGltZXN0YW1wKGRhdGVTdHJpbmcpO1xyXG5cdFx0XHRcclxuXHRcdFx0Ly8gU2hvdWxkIGJlIFVUQyBub29uIGZvciB0aGUgZ2l2ZW4gZGF0ZVxyXG5cdFx0XHRjb25zdCBleHBlY3RlZCA9IG5ldyBEYXRlKERhdGUuVVRDKDIwMjUsIDgsIDEsIDEyLCAwLCAwKSkuZ2V0VGltZSgpO1xyXG5cdFx0XHRleHBlY3QocmVzdWx0KS50b0JlKGV4cGVjdGVkKTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdGl0KFwic2hvdWxkIGhhbmRsZSB1bmRlZmluZWQgZGF0ZSBzdHJpbmdcIiwgKCkgPT4ge1xyXG5cdFx0XHRjb25zdCByZXN1bHQgPSBsb2NhbERhdGVTdHJpbmdUb1RpbWVzdGFtcChcIlwiKTtcclxuXHRcdFx0ZXhwZWN0KHJlc3VsdCkudG9CZVVuZGVmaW5lZCgpO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0aXQoXCJzaG91bGQgaGFuZGxlIGludmFsaWQgZGF0ZSBzdHJpbmdcIiwgKCkgPT4ge1xyXG5cdFx0XHRjb25zdCByZXN1bHQgPSBsb2NhbERhdGVTdHJpbmdUb1RpbWVzdGFtcChcImludmFsaWQtZGF0ZVwiKTtcclxuXHRcdFx0ZXhwZWN0KHJlc3VsdCkudG9CZVVuZGVmaW5lZCgpO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0aXQoXCJzaG91bGQgaGFuZGxlIGRhdGVzIGF0IHllYXIgYm91bmRhcmllc1wiLCAoKSA9PiB7XHJcblx0XHRcdGNvbnN0IGRhdGVTdHJpbmcgPSBcIjIwMjQtMTItMzFcIjtcclxuXHRcdFx0Y29uc3QgcmVzdWx0ID0gbG9jYWxEYXRlU3RyaW5nVG9UaW1lc3RhbXAoZGF0ZVN0cmluZyk7XHJcblx0XHRcdFxyXG5cdFx0XHRjb25zdCBleHBlY3RlZCA9IG5ldyBEYXRlKERhdGUuVVRDKDIwMjQsIDExLCAzMSwgMTIsIDAsIDApKS5nZXRUaW1lKCk7XHJcblx0XHRcdGV4cGVjdChyZXN1bHQpLnRvQmUoZXhwZWN0ZWQpO1xyXG5cdFx0fSk7XHJcblx0fSk7XHJcblxyXG5cdGRlc2NyaWJlKFwiUm91bmQtdHJpcCBjb252ZXJzaW9uXCIsICgpID0+IHtcclxuXHRcdGl0KFwic2hvdWxkIG1haW50YWluIGRhdGUgaW50ZWdyaXR5IHRocm91Z2ggcm91bmQtdHJpcCBjb252ZXJzaW9uXCIsICgpID0+IHtcclxuXHRcdFx0Y29uc3QgdGVzdERhdGVzID0gW1xyXG5cdFx0XHRcdFwiMjAyNS0wOS0wMVwiLFxyXG5cdFx0XHRcdFwiMjAyNC0xMi0zMVwiLFxyXG5cdFx0XHRcdFwiMjAyNS0wMS0wMVwiLFxyXG5cdFx0XHRcdFwiMjAyNC0wMi0yOVwiLCAvLyBMZWFwIHllYXJcclxuXHRcdFx0XHRcIjIwMjUtMDYtMTVcIixcclxuXHRcdFx0XTtcclxuXHJcblx0XHRcdGZvciAoY29uc3Qgb3JpZ2luYWxEYXRlIG9mIHRlc3REYXRlcykge1xyXG5cdFx0XHRcdGNvbnN0IHRpbWVzdGFtcCA9IGxvY2FsRGF0ZVN0cmluZ1RvVGltZXN0YW1wKG9yaWdpbmFsRGF0ZSk7XHJcblx0XHRcdFx0Y29uc3QgY29udmVydGVkQmFjayA9IHRpbWVzdGFtcFRvTG9jYWxEYXRlU3RyaW5nKHRpbWVzdGFtcCk7XHJcblx0XHRcdFx0ZXhwZWN0KGNvbnZlcnRlZEJhY2spLnRvQmUob3JpZ2luYWxEYXRlKTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0fSk7XHJcblxyXG5cdGRlc2NyaWJlKFwiVGltZXpvbmUgZWRnZSBjYXNlc1wiLCAoKSA9PiB7XHJcblx0XHRpdChcInNob3VsZCBoYW5kbGUgZGF0ZXMgY29ycmVjdGx5IGV2ZW4gd2hlbiBsb2NhbCB0aW1lIHdvdWxkIGJlIGRpZmZlcmVudCBkYXlcIiwgKCkgPT4ge1xyXG5cdFx0XHQvLyBUaGlzIHNpbXVsYXRlcyB0aGUgaXNzdWUgd2hlcmUgYSBkYXRlIHN0b3JlZCBhcyBVVEMgbm9vblxyXG5cdFx0XHQvLyBtaWdodCBhcHBlYXIgYXMgYSBkaWZmZXJlbnQgZGF5IGluIGNlcnRhaW4gdGltZXpvbmVzXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBDcmVhdGUgYSB0aW1lc3RhbXAgZm9yIDIwMjUtMDktMDEgYXQgVVRDIG5vb25cclxuXHRcdFx0Y29uc3QgdGltZXN0YW1wID0gbmV3IERhdGUoRGF0ZS5VVEMoMjAyNSwgOCwgMSwgMTIsIDAsIDApKS5nZXRUaW1lKCk7XHJcblx0XHRcdFxyXG5cdFx0XHQvLyBFdmVuIGlmIHRoZSB1c2VyIGlzIGluIGEgdGltZXpvbmUgd2hlcmUgdGhpcyB3b3VsZCBiZSBcclxuXHRcdFx0Ly8gMjAyNS0wOS0wMSAxOTowMCAoVVRDKzcpIG9yIDIwMjUtMDktMDEgMDg6MDAgKFVUQy00KSxcclxuXHRcdFx0Ly8gdGhlIGRpc3BsYXkgc2hvdWxkIHN0aWxsIHNob3cgMjAyNS0wOS0wMVxyXG5cdFx0XHRjb25zdCByZXN1bHQgPSB0aW1lc3RhbXBUb0xvY2FsRGF0ZVN0cmluZyh0aW1lc3RhbXApO1xyXG5cdFx0XHRleHBlY3QocmVzdWx0KS50b0JlKFwiMjAyNS0wOS0wMVwiKTtcclxuXHRcdH0pO1xyXG5cdH0pO1xyXG59KTsiXX0=