/**
 * Cycles the task status on the current line forward
 * @param checking Whether this is a check or an execution
 * @param editor The editor instance
 * @param ctx The markdown view or file info context
 * @param plugin The plugin instance
 * @returns Boolean indicating whether the command can be executed
 */
export function cycleTaskStatusForward(checking, editor, ctx, plugin) {
    return cycleTaskStatus(checking, editor, plugin, "forward");
}
/**
 * Cycles the task status on the current line backward
 * @param checking Whether this is a check or an execution
 * @param editor The editor instance
 * @param ctx The markdown view or file info context
 * @param plugin The plugin instance
 * @returns Boolean indicating whether the command can be executed
 */
export function cycleTaskStatusBackward(checking, editor, ctx, plugin) {
    return cycleTaskStatus(checking, editor, plugin, "backward");
}
/**
 * Cycles the task status on the current line in the specified direction
 * @param checking Whether this is a check or an execution
 * @param editor The editor instance
 * @param plugin The plugin instance
 * @param direction The direction to cycle: "forward" or "backward"
 * @returns Boolean indicating whether the command can be executed
 */
function cycleTaskStatus(checking, editor, plugin, direction) {
    // Get the current cursor position
    const cursor = editor.getCursor();
    // Get the text from the current line
    const line = editor.getLine(cursor.line);
    // Check if this line contains a task
    const taskRegex = /^[\s|\t]*([-*+]|\d+\.)\s+\[(.)]/;
    const match = line.match(taskRegex);
    if (!match) {
        // Not a task line
        return false;
    }
    // If just checking if the command is valid
    if (checking) {
        return true;
    }
    // Get the task cycle and marks from plugin settings
    const { cycle, marks, excludeMarksFromCycle } = getTaskStatusConfig(plugin);
    const remainingCycle = cycle.filter((state) => !excludeMarksFromCycle.includes(state));
    // If no cycle is defined, don't do anything
    if (remainingCycle.length === 0) {
        return false;
    }
    // Get the current mark
    const currentMark = match[2];
    // Find the current status in the cycle
    let currentStatusIndex = -1;
    for (let i = 0; i < remainingCycle.length; i++) {
        const state = remainingCycle[i];
        if (marks[state] === currentMark) {
            currentStatusIndex = i;
            break;
        }
    }
    // If we couldn't find the current status in the cycle, start from the first one
    if (currentStatusIndex === -1) {
        currentStatusIndex = 0;
    }
    // Calculate the next status based on direction
    let nextStatusIndex;
    if (direction === "forward") {
        nextStatusIndex = (currentStatusIndex + 1) % remainingCycle.length;
    }
    else {
        nextStatusIndex =
            (currentStatusIndex - 1 + remainingCycle.length) %
                remainingCycle.length;
    }
    const nextStatus = remainingCycle[nextStatusIndex];
    const nextMark = marks[nextStatus] || " ";
    // Find the positions of the mark in the line
    const startPos = line.indexOf("[") + 1;
    // Replace the mark
    editor.replaceRange(nextMark, { line: cursor.line, ch: startPos }, { line: cursor.line, ch: startPos + 1 });
    return true;
}
/**
 * Gets the task status configuration from the plugin settings
 * @param plugin The plugin instance
 * @returns Object containing the task cycle and marks
 */
function getTaskStatusConfig(plugin) {
    return {
        cycle: plugin.settings.taskStatusCycle,
        excludeMarksFromCycle: plugin.settings.excludeMarksFromCycle || [],
        marks: plugin.settings.taskStatusMarks,
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFza0N5Y2xlQ29tbWFuZHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJ0YXNrQ3ljbGVDb21tYW5kcy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFHQTs7Ozs7OztHQU9HO0FBQ0gsTUFBTSxVQUFVLHNCQUFzQixDQUNyQyxRQUFpQixFQUNqQixNQUFjLEVBQ2QsR0FBb0MsRUFDcEMsTUFBNkI7SUFFN0IsT0FBTyxlQUFlLENBQUMsUUFBUSxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsU0FBUyxDQUFDLENBQUM7QUFDN0QsQ0FBQztBQUVEOzs7Ozs7O0dBT0c7QUFDSCxNQUFNLFVBQVUsdUJBQXVCLENBQ3RDLFFBQWlCLEVBQ2pCLE1BQWMsRUFDZCxHQUFvQyxFQUNwQyxNQUE2QjtJQUU3QixPQUFPLGVBQWUsQ0FBQyxRQUFRLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxVQUFVLENBQUMsQ0FBQztBQUM5RCxDQUFDO0FBRUQ7Ozs7Ozs7R0FPRztBQUNILFNBQVMsZUFBZSxDQUN2QixRQUFpQixFQUNqQixNQUFjLEVBQ2QsTUFBNkIsRUFDN0IsU0FBaUM7SUFFakMsa0NBQWtDO0lBQ2xDLE1BQU0sTUFBTSxHQUFHLE1BQU0sQ0FBQyxTQUFTLEVBQUUsQ0FBQztJQUVsQyxxQ0FBcUM7SUFDckMsTUFBTSxJQUFJLEdBQUcsTUFBTSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7SUFFekMscUNBQXFDO0lBQ3JDLE1BQU0sU0FBUyxHQUFHLGlDQUFpQyxDQUFDO0lBQ3BELE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUM7SUFFcEMsSUFBSSxDQUFDLEtBQUssRUFBRTtRQUNYLGtCQUFrQjtRQUNsQixPQUFPLEtBQUssQ0FBQztLQUNiO0lBRUQsMkNBQTJDO0lBQzNDLElBQUksUUFBUSxFQUFFO1FBQ2IsT0FBTyxJQUFJLENBQUM7S0FDWjtJQUVELG9EQUFvRDtJQUNwRCxNQUFNLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxxQkFBcUIsRUFBRSxHQUFHLG1CQUFtQixDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQzVFLE1BQU0sY0FBYyxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQ2xDLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxDQUFDLHFCQUFxQixDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FDakQsQ0FBQztJQUVGLDRDQUE0QztJQUM1QyxJQUFJLGNBQWMsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1FBQ2hDLE9BQU8sS0FBSyxDQUFDO0tBQ2I7SUFFRCx1QkFBdUI7SUFDdkIsTUFBTSxXQUFXLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBRTdCLHVDQUF1QztJQUN2QyxJQUFJLGtCQUFrQixHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQzVCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxjQUFjLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1FBQy9DLE1BQU0sS0FBSyxHQUFHLGNBQWMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNoQyxJQUFJLEtBQUssQ0FBQyxLQUFLLENBQUMsS0FBSyxXQUFXLEVBQUU7WUFDakMsa0JBQWtCLEdBQUcsQ0FBQyxDQUFDO1lBQ3ZCLE1BQU07U0FDTjtLQUNEO0lBRUQsZ0ZBQWdGO0lBQ2hGLElBQUksa0JBQWtCLEtBQUssQ0FBQyxDQUFDLEVBQUU7UUFDOUIsa0JBQWtCLEdBQUcsQ0FBQyxDQUFDO0tBQ3ZCO0lBRUQsK0NBQStDO0lBQy9DLElBQUksZUFBZSxDQUFDO0lBQ3BCLElBQUksU0FBUyxLQUFLLFNBQVMsRUFBRTtRQUM1QixlQUFlLEdBQUcsQ0FBQyxrQkFBa0IsR0FBRyxDQUFDLENBQUMsR0FBRyxjQUFjLENBQUMsTUFBTSxDQUFDO0tBQ25FO1NBQU07UUFDTixlQUFlO1lBQ2QsQ0FBQyxrQkFBa0IsR0FBRyxDQUFDLEdBQUcsY0FBYyxDQUFDLE1BQU0sQ0FBQztnQkFDaEQsY0FBYyxDQUFDLE1BQU0sQ0FBQztLQUN2QjtJQUVELE1BQU0sVUFBVSxHQUFHLGNBQWMsQ0FBQyxlQUFlLENBQUMsQ0FBQztJQUNuRCxNQUFNLFFBQVEsR0FBRyxLQUFLLENBQUMsVUFBVSxDQUFDLElBQUksR0FBRyxDQUFDO0lBRTFDLDZDQUE2QztJQUM3QyxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUV2QyxtQkFBbUI7SUFDbkIsTUFBTSxDQUFDLFlBQVksQ0FDbEIsUUFBUSxFQUNSLEVBQUUsSUFBSSxFQUFFLE1BQU0sQ0FBQyxJQUFJLEVBQUUsRUFBRSxFQUFFLFFBQVEsRUFBRSxFQUNuQyxFQUFFLElBQUksRUFBRSxNQUFNLENBQUMsSUFBSSxFQUFFLEVBQUUsRUFBRSxRQUFRLEdBQUcsQ0FBQyxFQUFFLENBQ3ZDLENBQUM7SUFFRixPQUFPLElBQUksQ0FBQztBQUNiLENBQUM7QUFFRDs7OztHQUlHO0FBQ0gsU0FBUyxtQkFBbUIsQ0FBQyxNQUE2QjtJQUN6RCxPQUFPO1FBQ04sS0FBSyxFQUFFLE1BQU0sQ0FBQyxRQUFRLENBQUMsZUFBZTtRQUN0QyxxQkFBcUIsRUFBRSxNQUFNLENBQUMsUUFBUSxDQUFDLHFCQUFxQixJQUFJLEVBQUU7UUFDbEUsS0FBSyxFQUFFLE1BQU0sQ0FBQyxRQUFRLENBQUMsZUFBZTtLQUN0QyxDQUFDO0FBQ0gsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEVkaXRvciwgTWFya2Rvd25GaWxlSW5mbywgTWFya2Rvd25WaWV3IH0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcbmltcG9ydCBUYXNrUHJvZ3Jlc3NCYXJQbHVnaW4gZnJvbSBcIi4uL2luZGV4XCI7XHJcblxyXG4vKipcclxuICogQ3ljbGVzIHRoZSB0YXNrIHN0YXR1cyBvbiB0aGUgY3VycmVudCBsaW5lIGZvcndhcmRcclxuICogQHBhcmFtIGNoZWNraW5nIFdoZXRoZXIgdGhpcyBpcyBhIGNoZWNrIG9yIGFuIGV4ZWN1dGlvblxyXG4gKiBAcGFyYW0gZWRpdG9yIFRoZSBlZGl0b3IgaW5zdGFuY2VcclxuICogQHBhcmFtIGN0eCBUaGUgbWFya2Rvd24gdmlldyBvciBmaWxlIGluZm8gY29udGV4dFxyXG4gKiBAcGFyYW0gcGx1Z2luIFRoZSBwbHVnaW4gaW5zdGFuY2VcclxuICogQHJldHVybnMgQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGNvbW1hbmQgY2FuIGJlIGV4ZWN1dGVkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY3ljbGVUYXNrU3RhdHVzRm9yd2FyZChcclxuXHRjaGVja2luZzogYm9vbGVhbixcclxuXHRlZGl0b3I6IEVkaXRvcixcclxuXHRjdHg6IE1hcmtkb3duVmlldyB8IE1hcmtkb3duRmlsZUluZm8sXHJcblx0cGx1Z2luOiBUYXNrUHJvZ3Jlc3NCYXJQbHVnaW5cclxuKTogYm9vbGVhbiB7XHJcblx0cmV0dXJuIGN5Y2xlVGFza1N0YXR1cyhjaGVja2luZywgZWRpdG9yLCBwbHVnaW4sIFwiZm9yd2FyZFwiKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEN5Y2xlcyB0aGUgdGFzayBzdGF0dXMgb24gdGhlIGN1cnJlbnQgbGluZSBiYWNrd2FyZFxyXG4gKiBAcGFyYW0gY2hlY2tpbmcgV2hldGhlciB0aGlzIGlzIGEgY2hlY2sgb3IgYW4gZXhlY3V0aW9uXHJcbiAqIEBwYXJhbSBlZGl0b3IgVGhlIGVkaXRvciBpbnN0YW5jZVxyXG4gKiBAcGFyYW0gY3R4IFRoZSBtYXJrZG93biB2aWV3IG9yIGZpbGUgaW5mbyBjb250ZXh0XHJcbiAqIEBwYXJhbSBwbHVnaW4gVGhlIHBsdWdpbiBpbnN0YW5jZVxyXG4gKiBAcmV0dXJucyBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgY29tbWFuZCBjYW4gYmUgZXhlY3V0ZWRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjeWNsZVRhc2tTdGF0dXNCYWNrd2FyZChcclxuXHRjaGVja2luZzogYm9vbGVhbixcclxuXHRlZGl0b3I6IEVkaXRvcixcclxuXHRjdHg6IE1hcmtkb3duVmlldyB8IE1hcmtkb3duRmlsZUluZm8sXHJcblx0cGx1Z2luOiBUYXNrUHJvZ3Jlc3NCYXJQbHVnaW5cclxuKTogYm9vbGVhbiB7XHJcblx0cmV0dXJuIGN5Y2xlVGFza1N0YXR1cyhjaGVja2luZywgZWRpdG9yLCBwbHVnaW4sIFwiYmFja3dhcmRcIik7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDeWNsZXMgdGhlIHRhc2sgc3RhdHVzIG9uIHRoZSBjdXJyZW50IGxpbmUgaW4gdGhlIHNwZWNpZmllZCBkaXJlY3Rpb25cclxuICogQHBhcmFtIGNoZWNraW5nIFdoZXRoZXIgdGhpcyBpcyBhIGNoZWNrIG9yIGFuIGV4ZWN1dGlvblxyXG4gKiBAcGFyYW0gZWRpdG9yIFRoZSBlZGl0b3IgaW5zdGFuY2VcclxuICogQHBhcmFtIHBsdWdpbiBUaGUgcGx1Z2luIGluc3RhbmNlXHJcbiAqIEBwYXJhbSBkaXJlY3Rpb24gVGhlIGRpcmVjdGlvbiB0byBjeWNsZTogXCJmb3J3YXJkXCIgb3IgXCJiYWNrd2FyZFwiXHJcbiAqIEByZXR1cm5zIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBjb21tYW5kIGNhbiBiZSBleGVjdXRlZFxyXG4gKi9cclxuZnVuY3Rpb24gY3ljbGVUYXNrU3RhdHVzKFxyXG5cdGNoZWNraW5nOiBib29sZWFuLFxyXG5cdGVkaXRvcjogRWRpdG9yLFxyXG5cdHBsdWdpbjogVGFza1Byb2dyZXNzQmFyUGx1Z2luLFxyXG5cdGRpcmVjdGlvbjogXCJmb3J3YXJkXCIgfCBcImJhY2t3YXJkXCJcclxuKTogYm9vbGVhbiB7XHJcblx0Ly8gR2V0IHRoZSBjdXJyZW50IGN1cnNvciBwb3NpdGlvblxyXG5cdGNvbnN0IGN1cnNvciA9IGVkaXRvci5nZXRDdXJzb3IoKTtcclxuXHJcblx0Ly8gR2V0IHRoZSB0ZXh0IGZyb20gdGhlIGN1cnJlbnQgbGluZVxyXG5cdGNvbnN0IGxpbmUgPSBlZGl0b3IuZ2V0TGluZShjdXJzb3IubGluZSk7XHJcblxyXG5cdC8vIENoZWNrIGlmIHRoaXMgbGluZSBjb250YWlucyBhIHRhc2tcclxuXHRjb25zdCB0YXNrUmVnZXggPSAvXltcXHN8XFx0XSooWy0qK118XFxkK1xcLilcXHMrXFxbKC4pXS87XHJcblx0Y29uc3QgbWF0Y2ggPSBsaW5lLm1hdGNoKHRhc2tSZWdleCk7XHJcblxyXG5cdGlmICghbWF0Y2gpIHtcclxuXHRcdC8vIE5vdCBhIHRhc2sgbGluZVxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxuXHJcblx0Ly8gSWYganVzdCBjaGVja2luZyBpZiB0aGUgY29tbWFuZCBpcyB2YWxpZFxyXG5cdGlmIChjaGVja2luZykge1xyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fVxyXG5cclxuXHQvLyBHZXQgdGhlIHRhc2sgY3ljbGUgYW5kIG1hcmtzIGZyb20gcGx1Z2luIHNldHRpbmdzXHJcblx0Y29uc3QgeyBjeWNsZSwgbWFya3MsIGV4Y2x1ZGVNYXJrc0Zyb21DeWNsZSB9ID0gZ2V0VGFza1N0YXR1c0NvbmZpZyhwbHVnaW4pO1xyXG5cdGNvbnN0IHJlbWFpbmluZ0N5Y2xlID0gY3ljbGUuZmlsdGVyKFxyXG5cdFx0KHN0YXRlKSA9PiAhZXhjbHVkZU1hcmtzRnJvbUN5Y2xlLmluY2x1ZGVzKHN0YXRlKVxyXG5cdCk7XHJcblxyXG5cdC8vIElmIG5vIGN5Y2xlIGlzIGRlZmluZWQsIGRvbid0IGRvIGFueXRoaW5nXHJcblx0aWYgKHJlbWFpbmluZ0N5Y2xlLmxlbmd0aCA9PT0gMCkge1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxuXHJcblx0Ly8gR2V0IHRoZSBjdXJyZW50IG1hcmtcclxuXHRjb25zdCBjdXJyZW50TWFyayA9IG1hdGNoWzJdO1xyXG5cclxuXHQvLyBGaW5kIHRoZSBjdXJyZW50IHN0YXR1cyBpbiB0aGUgY3ljbGVcclxuXHRsZXQgY3VycmVudFN0YXR1c0luZGV4ID0gLTE7XHJcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCByZW1haW5pbmdDeWNsZS5sZW5ndGg7IGkrKykge1xyXG5cdFx0Y29uc3Qgc3RhdGUgPSByZW1haW5pbmdDeWNsZVtpXTtcclxuXHRcdGlmIChtYXJrc1tzdGF0ZV0gPT09IGN1cnJlbnRNYXJrKSB7XHJcblx0XHRcdGN1cnJlbnRTdGF0dXNJbmRleCA9IGk7XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gSWYgd2UgY291bGRuJ3QgZmluZCB0aGUgY3VycmVudCBzdGF0dXMgaW4gdGhlIGN5Y2xlLCBzdGFydCBmcm9tIHRoZSBmaXJzdCBvbmVcclxuXHRpZiAoY3VycmVudFN0YXR1c0luZGV4ID09PSAtMSkge1xyXG5cdFx0Y3VycmVudFN0YXR1c0luZGV4ID0gMDtcclxuXHR9XHJcblxyXG5cdC8vIENhbGN1bGF0ZSB0aGUgbmV4dCBzdGF0dXMgYmFzZWQgb24gZGlyZWN0aW9uXHJcblx0bGV0IG5leHRTdGF0dXNJbmRleDtcclxuXHRpZiAoZGlyZWN0aW9uID09PSBcImZvcndhcmRcIikge1xyXG5cdFx0bmV4dFN0YXR1c0luZGV4ID0gKGN1cnJlbnRTdGF0dXNJbmRleCArIDEpICUgcmVtYWluaW5nQ3ljbGUubGVuZ3RoO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRuZXh0U3RhdHVzSW5kZXggPVxyXG5cdFx0XHQoY3VycmVudFN0YXR1c0luZGV4IC0gMSArIHJlbWFpbmluZ0N5Y2xlLmxlbmd0aCkgJVxyXG5cdFx0XHRyZW1haW5pbmdDeWNsZS5sZW5ndGg7XHJcblx0fVxyXG5cclxuXHRjb25zdCBuZXh0U3RhdHVzID0gcmVtYWluaW5nQ3ljbGVbbmV4dFN0YXR1c0luZGV4XTtcclxuXHRjb25zdCBuZXh0TWFyayA9IG1hcmtzW25leHRTdGF0dXNdIHx8IFwiIFwiO1xyXG5cclxuXHQvLyBGaW5kIHRoZSBwb3NpdGlvbnMgb2YgdGhlIG1hcmsgaW4gdGhlIGxpbmVcclxuXHRjb25zdCBzdGFydFBvcyA9IGxpbmUuaW5kZXhPZihcIltcIikgKyAxO1xyXG5cclxuXHQvLyBSZXBsYWNlIHRoZSBtYXJrXHJcblx0ZWRpdG9yLnJlcGxhY2VSYW5nZShcclxuXHRcdG5leHRNYXJrLFxyXG5cdFx0eyBsaW5lOiBjdXJzb3IubGluZSwgY2g6IHN0YXJ0UG9zIH0sXHJcblx0XHR7IGxpbmU6IGN1cnNvci5saW5lLCBjaDogc3RhcnRQb3MgKyAxIH1cclxuXHQpO1xyXG5cclxuXHRyZXR1cm4gdHJ1ZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldHMgdGhlIHRhc2sgc3RhdHVzIGNvbmZpZ3VyYXRpb24gZnJvbSB0aGUgcGx1Z2luIHNldHRpbmdzXHJcbiAqIEBwYXJhbSBwbHVnaW4gVGhlIHBsdWdpbiBpbnN0YW5jZVxyXG4gKiBAcmV0dXJucyBPYmplY3QgY29udGFpbmluZyB0aGUgdGFzayBjeWNsZSBhbmQgbWFya3NcclxuICovXHJcbmZ1bmN0aW9uIGdldFRhc2tTdGF0dXNDb25maWcocGx1Z2luOiBUYXNrUHJvZ3Jlc3NCYXJQbHVnaW4pIHtcclxuXHRyZXR1cm4ge1xyXG5cdFx0Y3ljbGU6IHBsdWdpbi5zZXR0aW5ncy50YXNrU3RhdHVzQ3ljbGUsXHJcblx0XHRleGNsdWRlTWFya3NGcm9tQ3ljbGU6IHBsdWdpbi5zZXR0aW5ncy5leGNsdWRlTWFya3NGcm9tQ3ljbGUgfHwgW10sXHJcblx0XHRtYXJrczogcGx1Z2luLnNldHRpbmdzLnRhc2tTdGF0dXNNYXJrcyxcclxuXHR9O1xyXG59XHJcbiJdfQ==