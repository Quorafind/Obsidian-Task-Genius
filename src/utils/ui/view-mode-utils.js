/**
 * Utility functions for managing view mode state across the application
 */
/**
 * Get the global default view mode from plugin settings
 * @param plugin The TaskProgressBarPlugin instance
 * @returns true for tree view, false for list view
 */
export function getDefaultViewMode(plugin) {
    return plugin.settings.defaultViewMode === "tree";
}
/**
 * Get the saved view mode for a specific view from localStorage
 * @param app The Obsidian App instance
 * @param viewId The view identifier
 * @returns true for tree view, false for list view, null if not saved
 */
export function getSavedViewMode(app, viewId) {
    const saved = app.loadLocalStorage(`task-genius:view-mode:${viewId}`);
    if (saved === null || saved === undefined) {
        return null;
    }
    return saved === "tree";
}
/**
 * Save the view mode for a specific view to localStorage
 * @param app The Obsidian App instance
 * @param viewId The view identifier
 * @param isTreeView true for tree view, false for list view
 */
export function saveViewMode(app, viewId, isTreeView) {
    const modeString = isTreeView ? "tree" : "list";
    app.saveLocalStorage(`task-genius:view-mode:${viewId}`, modeString);
}
/**
 * Get the initial view mode for a view, considering saved state and global default
 * @param app The Obsidian App instance
 * @param plugin The TaskProgressBarPlugin instance
 * @param viewId The view identifier
 * @returns true for tree view, false for list view
 */
export function getInitialViewMode(app, plugin, viewId) {
    // First check if there's a saved state for this specific view
    const savedMode = getSavedViewMode(app, viewId);
    if (savedMode !== null) {
        return savedMode;
    }
    // If no saved state, use the global default
    return getDefaultViewMode(plugin);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmlldy1tb2RlLXV0aWxzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsidmlldy1tb2RlLXV0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUdBOztHQUVHO0FBRUg7Ozs7R0FJRztBQUNILE1BQU0sVUFBVSxrQkFBa0IsQ0FBQyxNQUE2QjtJQUMvRCxPQUFPLE1BQU0sQ0FBQyxRQUFRLENBQUMsZUFBZSxLQUFLLE1BQU0sQ0FBQztBQUNuRCxDQUFDO0FBRUQ7Ozs7O0dBS0c7QUFDSCxNQUFNLFVBQVUsZ0JBQWdCLENBQUMsR0FBUSxFQUFFLE1BQWM7SUFDeEQsTUFBTSxLQUFLLEdBQUcsR0FBRyxDQUFDLGdCQUFnQixDQUFDLHlCQUF5QixNQUFNLEVBQUUsQ0FBQyxDQUFDO0lBQ3RFLElBQUksS0FBSyxLQUFLLElBQUksSUFBSSxLQUFLLEtBQUssU0FBUyxFQUFFO1FBQzFDLE9BQU8sSUFBSSxDQUFDO0tBQ1o7SUFDRCxPQUFPLEtBQUssS0FBSyxNQUFNLENBQUM7QUFDekIsQ0FBQztBQUVEOzs7OztHQUtHO0FBQ0gsTUFBTSxVQUFVLFlBQVksQ0FBQyxHQUFRLEVBQUUsTUFBYyxFQUFFLFVBQW1CO0lBQ3pFLE1BQU0sVUFBVSxHQUFHLFVBQVUsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUM7SUFDaEQsR0FBRyxDQUFDLGdCQUFnQixDQUFDLHlCQUF5QixNQUFNLEVBQUUsRUFBRSxVQUFVLENBQUMsQ0FBQztBQUNyRSxDQUFDO0FBRUQ7Ozs7OztHQU1HO0FBQ0gsTUFBTSxVQUFVLGtCQUFrQixDQUNqQyxHQUFRLEVBQ1IsTUFBNkIsRUFDN0IsTUFBYztJQUVkLDhEQUE4RDtJQUM5RCxNQUFNLFNBQVMsR0FBRyxnQkFBZ0IsQ0FBQyxHQUFHLEVBQUUsTUFBTSxDQUFDLENBQUM7SUFDaEQsSUFBSSxTQUFTLEtBQUssSUFBSSxFQUFFO1FBQ3ZCLE9BQU8sU0FBUyxDQUFDO0tBQ2pCO0lBRUQsNENBQTRDO0lBQzVDLE9BQU8sa0JBQWtCLENBQUMsTUFBTSxDQUFDLENBQUM7QUFDbkMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFwcCB9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5pbXBvcnQgVGFza1Byb2dyZXNzQmFyUGx1Z2luIGZyb20gXCIuLi8uLi9pbmRleFwiO1xyXG5cclxuLyoqXHJcbiAqIFV0aWxpdHkgZnVuY3Rpb25zIGZvciBtYW5hZ2luZyB2aWV3IG1vZGUgc3RhdGUgYWNyb3NzIHRoZSBhcHBsaWNhdGlvblxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIGdsb2JhbCBkZWZhdWx0IHZpZXcgbW9kZSBmcm9tIHBsdWdpbiBzZXR0aW5nc1xyXG4gKiBAcGFyYW0gcGx1Z2luIFRoZSBUYXNrUHJvZ3Jlc3NCYXJQbHVnaW4gaW5zdGFuY2VcclxuICogQHJldHVybnMgdHJ1ZSBmb3IgdHJlZSB2aWV3LCBmYWxzZSBmb3IgbGlzdCB2aWV3XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVmYXVsdFZpZXdNb2RlKHBsdWdpbjogVGFza1Byb2dyZXNzQmFyUGx1Z2luKTogYm9vbGVhbiB7XHJcblx0cmV0dXJuIHBsdWdpbi5zZXR0aW5ncy5kZWZhdWx0Vmlld01vZGUgPT09IFwidHJlZVwiO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IHRoZSBzYXZlZCB2aWV3IG1vZGUgZm9yIGEgc3BlY2lmaWMgdmlldyBmcm9tIGxvY2FsU3RvcmFnZVxyXG4gKiBAcGFyYW0gYXBwIFRoZSBPYnNpZGlhbiBBcHAgaW5zdGFuY2VcclxuICogQHBhcmFtIHZpZXdJZCBUaGUgdmlldyBpZGVudGlmaWVyXHJcbiAqIEByZXR1cm5zIHRydWUgZm9yIHRyZWUgdmlldywgZmFsc2UgZm9yIGxpc3QgdmlldywgbnVsbCBpZiBub3Qgc2F2ZWRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRTYXZlZFZpZXdNb2RlKGFwcDogQXBwLCB2aWV3SWQ6IHN0cmluZyk6IGJvb2xlYW4gfCBudWxsIHtcclxuXHRjb25zdCBzYXZlZCA9IGFwcC5sb2FkTG9jYWxTdG9yYWdlKGB0YXNrLWdlbml1czp2aWV3LW1vZGU6JHt2aWV3SWR9YCk7XHJcblx0aWYgKHNhdmVkID09PSBudWxsIHx8IHNhdmVkID09PSB1bmRlZmluZWQpIHtcclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH1cclxuXHRyZXR1cm4gc2F2ZWQgPT09IFwidHJlZVwiO1xyXG59XHJcblxyXG4vKipcclxuICogU2F2ZSB0aGUgdmlldyBtb2RlIGZvciBhIHNwZWNpZmljIHZpZXcgdG8gbG9jYWxTdG9yYWdlXHJcbiAqIEBwYXJhbSBhcHAgVGhlIE9ic2lkaWFuIEFwcCBpbnN0YW5jZVxyXG4gKiBAcGFyYW0gdmlld0lkIFRoZSB2aWV3IGlkZW50aWZpZXJcclxuICogQHBhcmFtIGlzVHJlZVZpZXcgdHJ1ZSBmb3IgdHJlZSB2aWV3LCBmYWxzZSBmb3IgbGlzdCB2aWV3XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc2F2ZVZpZXdNb2RlKGFwcDogQXBwLCB2aWV3SWQ6IHN0cmluZywgaXNUcmVlVmlldzogYm9vbGVhbik6IHZvaWQge1xyXG5cdGNvbnN0IG1vZGVTdHJpbmcgPSBpc1RyZWVWaWV3ID8gXCJ0cmVlXCIgOiBcImxpc3RcIjtcclxuXHRhcHAuc2F2ZUxvY2FsU3RvcmFnZShgdGFzay1nZW5pdXM6dmlldy1tb2RlOiR7dmlld0lkfWAsIG1vZGVTdHJpbmcpO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IHRoZSBpbml0aWFsIHZpZXcgbW9kZSBmb3IgYSB2aWV3LCBjb25zaWRlcmluZyBzYXZlZCBzdGF0ZSBhbmQgZ2xvYmFsIGRlZmF1bHRcclxuICogQHBhcmFtIGFwcCBUaGUgT2JzaWRpYW4gQXBwIGluc3RhbmNlXHJcbiAqIEBwYXJhbSBwbHVnaW4gVGhlIFRhc2tQcm9ncmVzc0JhclBsdWdpbiBpbnN0YW5jZVxyXG4gKiBAcGFyYW0gdmlld0lkIFRoZSB2aWV3IGlkZW50aWZpZXJcclxuICogQHJldHVybnMgdHJ1ZSBmb3IgdHJlZSB2aWV3LCBmYWxzZSBmb3IgbGlzdCB2aWV3XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW5pdGlhbFZpZXdNb2RlKFxyXG5cdGFwcDogQXBwLFxyXG5cdHBsdWdpbjogVGFza1Byb2dyZXNzQmFyUGx1Z2luLFxyXG5cdHZpZXdJZDogc3RyaW5nXHJcbik6IGJvb2xlYW4ge1xyXG5cdC8vIEZpcnN0IGNoZWNrIGlmIHRoZXJlJ3MgYSBzYXZlZCBzdGF0ZSBmb3IgdGhpcyBzcGVjaWZpYyB2aWV3XHJcblx0Y29uc3Qgc2F2ZWRNb2RlID0gZ2V0U2F2ZWRWaWV3TW9kZShhcHAsIHZpZXdJZCk7XHJcblx0aWYgKHNhdmVkTW9kZSAhPT0gbnVsbCkge1xyXG5cdFx0cmV0dXJuIHNhdmVkTW9kZTtcclxuXHR9XHJcblxyXG5cdC8vIElmIG5vIHNhdmVkIHN0YXRlLCB1c2UgdGhlIGdsb2JhbCBkZWZhdWx0XHJcblx0cmV0dXJuIGdldERlZmF1bHRWaWV3TW9kZShwbHVnaW4pO1xyXG59XHJcbiJdfQ==