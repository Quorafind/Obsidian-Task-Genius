import { __rest } from "tslib";
/**
 * Utility functions for converting between timestamps and TimeComponents
 * and combining date and time components into full datetime objects
 */
/**
 * Convert a timestamp to a TimeComponent (extracts time portion)
 * @param timestamp - Unix timestamp in milliseconds
 * @returns TimeComponent representing the time portion
 */
export function timestampToTimeComponent(timestamp) {
    const date = new Date(timestamp);
    const isLikelyDateOnly = date.getUTCHours() === 0 &&
        date.getUTCMinutes() === 0 &&
        date.getUTCSeconds() === 0 &&
        date.getUTCMilliseconds() === 0;
    const hour = isLikelyDateOnly ? 0 : date.getHours();
    const minute = isLikelyDateOnly ? 0 : date.getMinutes();
    const secondValue = isLikelyDateOnly ? 0 : date.getSeconds();
    const second = secondValue !== undefined && secondValue !== 0 ? secondValue : undefined;
    return {
        hour,
        minute,
        second,
        originalText: `${hour.toString().padStart(2, '0')}:${minute
            .toString()
            .padStart(2, '0')}${second !== undefined ? `:${second
            .toString()
            .padStart(2, '0')}` : ''}`,
        isRange: false,
    };
}
/**
 * Convert a TimeComponent to time in milliseconds (time portion only)
 * @param timeComponent - TimeComponent to convert
 * @returns Time in milliseconds from start of day
 */
export function timeComponentToMilliseconds(timeComponent) {
    return (timeComponent.hour * 60 * 60 + timeComponent.minute * 60 + (timeComponent.second || 0)) * 1000;
}
/**
 * Combine a date timestamp with a TimeComponent to create a full datetime
 * @param dateTimestamp - Date portion as timestamp (time will be ignored)
 * @param timeComponent - Time component to combine
 * @returns Full datetime as Date object
 */
export function combineDateAndTime(dateTimestamp, timeComponent) {
    const date = new Date(dateTimestamp);
    // Reset time to start of day, then add time component
    date.setHours(0, 0, 0, 0);
    date.setHours(timeComponent.hour, timeComponent.minute, timeComponent.second || 0, 0);
    return date;
}
/**
 * Extract date portion from timestamp (sets time to 00:00:00)
 * @param timestamp - Full datetime timestamp
 * @returns Date with time set to start of day
 */
export function extractDatePortion(timestamp) {
    const date = new Date(timestamp);
    date.setHours(0, 0, 0, 0);
    return date;
}
/**
 * Create enhanced datetime objects from standard metadata and time components
 * @param metadata - Standard task metadata with timestamps
 * @param timeComponents - Time components to combine with dates
 * @returns Enhanced dates object with combined datetime values
 */
export function createEnhancedDates(metadata, timeComponents) {
    const enhancedDates = {};
    // Combine start date and time
    if (metadata.startDate && timeComponents.startTime) {
        enhancedDates.startDateTime = combineDateAndTime(metadata.startDate, timeComponents.startTime);
    }
    // Combine end date and time (use start date if no specific end date)
    if (timeComponents.endTime) {
        const baseDate = metadata.startDate || metadata.dueDate || metadata.scheduledDate;
        if (baseDate) {
            enhancedDates.endDateTime = combineDateAndTime(baseDate, timeComponents.endTime);
        }
    }
    // Combine due date and time
    if (metadata.dueDate && timeComponents.dueTime) {
        enhancedDates.dueDateTime = combineDateAndTime(metadata.dueDate, timeComponents.dueTime);
    }
    // If we have a due date but only scheduled time, use it for scheduled and due datetimes
    if (metadata.dueDate && !metadata.scheduledDate && timeComponents.scheduledTime) {
        if (!enhancedDates.dueDateTime) {
            enhancedDates.dueDateTime = combineDateAndTime(metadata.dueDate, timeComponents.scheduledTime);
        }
        if (!enhancedDates.scheduledDateTime) {
            enhancedDates.scheduledDateTime = combineDateAndTime(metadata.dueDate, timeComponents.scheduledTime);
        }
    }
    // Combine scheduled date and time
    if (metadata.scheduledDate && timeComponents.scheduledTime) {
        enhancedDates.scheduledDateTime = combineDateAndTime(metadata.scheduledDate, timeComponents.scheduledTime);
    }
    return enhancedDates;
}
/**
 * Convert standard task metadata to enhanced metadata with time components
 * @param metadata - Standard task metadata
 * @param timeComponents - Optional time components to add
 * @returns Enhanced task metadata
 */
export function enhanceTaskMetadata(metadata, timeComponents) {
    const enhanced = Object.assign({}, metadata);
    if (timeComponents) {
        enhanced.timeComponents = timeComponents;
        enhanced.enhancedDates = createEnhancedDates(metadata, timeComponents);
    }
    return enhanced;
}
/**
 * Extract time components from existing timestamps in metadata
 * @param metadata - Standard task metadata with timestamps
 * @returns Time components extracted from timestamps
 */
export function extractTimeComponentsFromMetadata(metadata) {
    const timeComponents = {};
    if (metadata.startDate) {
        timeComponents.startTime = timestampToTimeComponent(metadata.startDate);
    }
    if (metadata.dueDate) {
        timeComponents.dueTime = timestampToTimeComponent(metadata.dueDate);
    }
    if (metadata.scheduledDate) {
        timeComponents.scheduledTime = timestampToTimeComponent(metadata.scheduledDate);
    }
    return timeComponents;
}
/**
 * Backward compatibility helper: convert enhanced metadata to standard format
 * @param enhanced - Enhanced task metadata
 * @returns Standard task metadata (loses time component information)
 */
export function downgradeToStandardMetadata(enhanced) {
    const { timeComponents, enhancedDates } = enhanced, standard = __rest(enhanced, ["timeComponents", "enhancedDates"]);
    // If we have enhanced dates, use those as the primary timestamps
    if (enhancedDates) {
        if (enhancedDates.startDateTime) {
            standard.startDate = enhancedDates.startDateTime.getTime();
        }
        if (enhancedDates.dueDateTime) {
            standard.dueDate = enhancedDates.dueDateTime.getTime();
        }
        if (enhancedDates.scheduledDateTime) {
            standard.scheduledDate = enhancedDates.scheduledDateTime.getTime();
        }
    }
    return standard;
}
/**
 * Check if metadata has any time components
 * @param metadata - Enhanced task metadata
 * @returns True if metadata contains time components
 */
export function hasTimeComponents(metadata) {
    return !!(metadata.timeComponents && (metadata.timeComponents.startTime ||
        metadata.timeComponents.endTime ||
        metadata.timeComponents.dueTime ||
        metadata.timeComponents.scheduledTime));
}
/**
 * Validate time component values
 * @param timeComponent - Time component to validate
 * @returns True if valid, false otherwise
 */
export function validateTimeComponent(timeComponent) {
    return (timeComponent.hour >= 0 && timeComponent.hour <= 23 &&
        timeComponent.minute >= 0 && timeComponent.minute <= 59 &&
        (timeComponent.second === undefined || (timeComponent.second >= 0 && timeComponent.second <= 59)));
}
/**
 * Create a time component from hour and minute values
 * @param hour - Hour (0-23)
 * @param minute - Minute (0-59)
 * @param second - Optional second (0-59)
 * @param originalText - Original text that was parsed
 * @returns TimeComponent object
 */
export function createTimeComponent(hour, minute, second, originalText) {
    const timeComponent = {
        hour,
        minute,
        second,
        originalText: originalText || `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}${second !== undefined ? ':' + second.toString().padStart(2, '0') : ''}`,
        isRange: false
    };
    if (!validateTimeComponent(timeComponent)) {
        throw new Error(`Invalid time component: ${hour}:${minute}${second !== undefined ? ':' + second : ''}`);
    }
    return timeComponent;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFzay1tZXRhZGF0YS11dGlscy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInRhc2stbWV0YWRhdGEtdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUdBOzs7R0FHRztBQUVIOzs7O0dBSUc7QUFDSCxNQUFNLFVBQVUsd0JBQXdCLENBQUMsU0FBaUI7SUFDekQsTUFBTSxJQUFJLEdBQUcsSUFBSSxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDakMsTUFBTSxnQkFBZ0IsR0FDckIsSUFBSSxDQUFDLFdBQVcsRUFBRSxLQUFLLENBQUM7UUFDeEIsSUFBSSxDQUFDLGFBQWEsRUFBRSxLQUFLLENBQUM7UUFDMUIsSUFBSSxDQUFDLGFBQWEsRUFBRSxLQUFLLENBQUM7UUFDMUIsSUFBSSxDQUFDLGtCQUFrQixFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQ2pDLE1BQU0sSUFBSSxHQUFHLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUNwRCxNQUFNLE1BQU0sR0FBRyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7SUFDeEQsTUFBTSxXQUFXLEdBQUcsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO0lBQzdELE1BQU0sTUFBTSxHQUNYLFdBQVcsS0FBSyxTQUFTLElBQUksV0FBVyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUM7SUFDMUUsT0FBTztRQUNOLElBQUk7UUFDSixNQUFNO1FBQ04sTUFBTTtRQUNOLFlBQVksRUFBRSxHQUFHLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxJQUFJLE1BQU07YUFDekQsUUFB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cm9tIFwiLi4vdHlwZXMvdGltZS1wYXJzaW5nXCI7XHJcbmltcG9ydCB7IFN0YW5kYXJkVGFza01ldGFkYXRhLCBFbmhhbmNlZFN0YW5kYXJkVGFza01ldGFkYXRhIH0gZnJvbSBcIi4uL3R5cGVzL3Rhc2tcIjtcclxuXHJcbi8qKlxyXG4gKiBVdGlsaXR5IGZ1bmN0aW9ucyBmb3IgY29udmVydGluZyBiZXR3ZWVuIHRpbWVzdGFtcHMgYW5kIFRpbWVDb21wb25lbnRzXHJcbiAqIGFuZCBjb21iaW5pbmcgZGF0ZSBhbmQgdGltZSBjb21wb25lbnRzIGludG8gZnVsbCBkYXRldGltZSBvYmplY3RzXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnQgYSB0aW1lc3RhbXAgdG8gYSBUaW1lQ29tcG9uZW50IChleHRyYWN0cyB0aW1lIHBvcnRpb24pXHJcbiAqIEBwYXJhbSB0aW1lc3RhbXAgLSBVbml4IHRpbWVzdGFtcCBpbiBtaWxsaXNlY29uZHNcclxuICogQHJldHVybnMgVGltZUNvbXBvbmVudCByZXByZXNlbnRpbmcgdGhlIHRpbWUgcG9ydGlvblxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHRpbWVzdGFtcFRvVGltZUNvbXBvbmVudCh0aW1lc3RhbXA6IG51bWJlcik6IFRpbWVDb21wb25lbnQge1xyXG5cdGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSh0aW1lc3RhbXApO1xyXG5cdGNvbnN0IGlzTGlrZWx5RGF0ZU9ubHkgPVxyXG5cdFx0ZGF0ZS5nZXRVVENIb3VycygpID09PSAwICYmXHJcblx0XHRkYXRlLmdldFVUQ01pbnV0ZXMoKSA9PT0gMCAmJlxyXG5cdFx0ZGF0ZS5nZXRVVENTZWNvbmRzKCkgPT09IDAgJiZcclxuXHRcdGRhdGUuZ2V0VVRDTWlsbGlzZWNvbmRzKCkgPT09IDA7XHJcblx0Y29uc3QgaG91ciA9IGlzTGlrZWx5RGF0ZU9ubHkgPyAwIDogZGF0ZS5nZXRIb3VycygpO1xyXG5cdGNvbnN0IG1pbnV0ZSA9IGlzTGlrZWx5RGF0ZU9ubHkgPyAwIDogZGF0ZS5nZXRNaW51dGVzKCk7XHJcblx0Y29uc3Qgc2Vjb25kVmFsdWUgPSBpc0xpa2VseURhdGVPbmx5ID8gMCA6IGRhdGUuZ2V0U2Vjb25kcygpO1xyXG5cdGNvbnN0IHNlY29uZCA9XHJcblx0XHRzZWNvbmRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIHNlY29uZFZhbHVlICE9PSAwID8gc2Vjb25kVmFsdWUgOiB1bmRlZmluZWQ7XHJcblx0cmV0dXJuIHtcclxuXHRcdGhvdXIsXHJcblx0XHRtaW51dGUsXHJcblx0XHRzZWNvbmQsXHJcblx0XHRvcmlnaW5hbFRleHQ6IGAke2hvdXIudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpfToke21pbnV0ZVxyXG5cdFx0XHQudG9TdHJpbmcoKVxyXG5cdFx0XHQucGFkU3RhcnQoMiwgJzAnKX0ke3NlY29uZCAhPT0gdW5kZWZpbmVkID8gYDoke3NlY29uZFxyXG5cdFx0XHQudG9TdHJpbmcoKVxyXG5cdFx0XHQucGFkU3RhcnQoMiwgJzAnKX1gIDogJyd9YCxcclxuXHRcdGlzUmFuZ2U6IGZhbHNlLFxyXG5cdH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0IGEgVGltZUNvbXBvbmVudCB0byB0aW1lIGluIG1pbGxpc2Vjb25kcyAodGltZSBwb3J0aW9uIG9ubHkpXHJcbiAqIEBwYXJhbSB0aW1lQ29tcG9uZW50IC0gVGltZUNvbXBvbmVudCB0byBjb252ZXJ0XHJcbiAqIEByZXR1cm5zIFRpbWUgaW4gbWlsbGlzZWNvbmRzIGZyb20gc3RhcnQgb2YgZGF5XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdGltZUNvbXBvbmVudFRvTWlsbGlzZWNvbmRzKHRpbWVDb21wb25lbnQ6IFRpbWVDb21wb25lbnQpOiBudW1iZXIge1xyXG5cdHJldHVybiAodGltZUNvbXBvbmVudC5ob3VyICogNjAgKiA2MCArIHRpbWVDb21wb25lbnQubWludXRlICogNjAgKyAodGltZUNvbXBvbmVudC5zZWNvbmQgfHwgMCkpICogMTAwMDtcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbWJpbmUgYSBkYXRlIHRpbWVzdGFtcCB3aXRoIGEgVGltZUNvbXBvbmVudCB0byBjcmVhdGUgYSBmdWxsIGRhdGV0aW1lXHJcbiAqIEBwYXJhbSBkYXRlVGltZXN0YW1wIC0gRGF0ZSBwb3J0aW9uIGFzIHRpbWVzdGFtcCAodGltZSB3aWxsIGJlIGlnbm9yZWQpXHJcbiAqIEBwYXJhbSB0aW1lQ29tcG9uZW50IC0gVGltZSBjb21wb25lbnQgdG8gY29tYmluZVxyXG4gKiBAcmV0dXJucyBGdWxsIGRhdGV0aW1lIGFzIERhdGUgb2JqZWN0XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29tYmluZURhdGVBbmRUaW1lKGRhdGVUaW1lc3RhbXA6IG51bWJlciwgdGltZUNvbXBvbmVudDogVGltZUNvbXBvbmVudCk6IERhdGUge1xyXG5cdGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShkYXRlVGltZXN0YW1wKTtcclxuXHQvLyBSZXNldCB0aW1lIHRvIHN0YXJ0IG9mIGRheSwgdGhlbiBhZGQgdGltZSBjb21wb25lbnRcclxuXHRkYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xyXG5cdGRhdGUuc2V0SG91cnModGltZUNvbXBvbmVudC5ob3VyLCB0aW1lQ29tcG9uZW50Lm1pbnV0ZSwgdGltZUNvbXBvbmVudC5zZWNvbmQgfHwgMCwgMCk7XHJcblx0cmV0dXJuIGRhdGU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFeHRyYWN0IGRhdGUgcG9ydGlvbiBmcm9tIHRpbWVzdGFtcCAoc2V0cyB0aW1lIHRvIDAwOjAwOjAwKVxyXG4gKiBAcGFyYW0gdGltZXN0YW1wIC0gRnVsbCBkYXRldGltZSB0aW1lc3RhbXBcclxuICogQHJldHVybnMgRGF0ZSB3aXRoIHRpbWUgc2V0IHRvIHN0YXJ0IG9mIGRheVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3REYXRlUG9ydGlvbih0aW1lc3RhbXA6IG51bWJlcik6IERhdGUge1xyXG5cdGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSh0aW1lc3RhbXApO1xyXG5cdGRhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XHJcblx0cmV0dXJuIGRhdGU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGUgZW5oYW5jZWQgZGF0ZXRpbWUgb2JqZWN0cyBmcm9tIHN0YW5kYXJkIG1ldGFkYXRhIGFuZCB0aW1lIGNvbXBvbmVudHNcclxuICogQHBhcmFtIG1ldGFkYXRhIC0gU3RhbmRhcmQgdGFzayBtZXRhZGF0YSB3aXRoIHRpbWVzdGFtcHNcclxuICogQHBhcmFtIHRpbWVDb21wb25lbnRzIC0gVGltZSBjb21wb25lbnRzIHRvIGNvbWJpbmUgd2l0aCBkYXRlc1xyXG4gKiBAcmV0dXJucyBFbmhhbmNlZCBkYXRlcyBvYmplY3Qgd2l0aCBjb21iaW5lZCBkYXRldGltZSB2YWx1ZXNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFbmhhbmNlZERhdGVzKFxyXG5cdG1ldGFkYXRhOiBTdGFuZGFyZFRhc2tNZXRhZGF0YSxcclxuXHR0aW1lQ29tcG9uZW50czogTm9uTnVsbGFibGU8RW5oYW5jZWRTdGFuZGFyZFRhc2tNZXRhZGF0YVsndGltZUNvbXBvbmVudHMnXT5cclxuKTogTm9uTnVsbGFibGU8RW5oYW5jZWRTdGFuZGFyZFRhc2tNZXRhZGF0YVsnZW5oYW5jZWREYXRlcyddPiB7XHJcblx0Y29uc3QgZW5oYW5jZWREYXRlczogTm9uTnVsbGFibGU8RW5oYW5jZWRTdGFuZGFyZFRhc2tNZXRhZGF0YVsnZW5oYW5jZWREYXRlcyddPiA9IHt9O1xyXG5cclxuXHQvLyBDb21iaW5lIHN0YXJ0IGRhdGUgYW5kIHRpbWVcclxuXHRpZiAobWV0YWRhdGEuc3RhcnREYXRlICYmIHRpbWVDb21wb25lbnRzLnN0YXJ0VGltZSkge1xyXG5cdFx0ZW5oYW5jZWREYXRlcy5zdGFydERhdGVUaW1lID0gY29tYmluZURhdGVBbmRUaW1lKG1ldGFkYXRhLnN0YXJ0RGF0ZSwgdGltZUNvbXBvbmVudHMuc3RhcnRUaW1lKTtcclxuXHR9XHJcblxyXG5cdC8vIENvbWJpbmUgZW5kIGRhdGUgYW5kIHRpbWUgKHVzZSBzdGFydCBkYXRlIGlmIG5vIHNwZWNpZmljIGVuZCBkYXRlKVxyXG5cdGlmICh0aW1lQ29tcG9uZW50cy5lbmRUaW1lKSB7XHJcblx0XHRjb25zdCBiYXNlRGF0ZSA9IG1ldGFkYXRhLnN0YXJ0RGF0ZSB8fCBtZXRhZGF0YS5kdWVEYXRlIHx8IG1ldGFkYXRhLnNjaGVkdWxlZERhdGU7XHJcblx0XHRpZiAoYmFzZURhdGUpIHtcclxuXHRcdFx0ZW5oYW5jZWREYXRlcy5lbmREYXRlVGltZSA9IGNvbWJpbmVEYXRlQW5kVGltZShiYXNlRGF0ZSwgdGltZUNvbXBvbmVudHMuZW5kVGltZSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyBDb21iaW5lIGR1ZSBkYXRlIGFuZCB0aW1lXHJcblx0aWYgKG1ldGFkYXRhLmR1ZURhdGUgJiYgdGltZUNvbXBvbmVudHMuZHVlVGltZSkge1xyXG5cdFx0ZW5oYW5jZWREYXRlcy5kdWVEYXRlVGltZSA9IGNvbWJpbmVEYXRlQW5kVGltZShtZXRhZGF0YS5kdWVEYXRlLCB0aW1lQ29tcG9uZW50cy5kdWVUaW1lKTtcclxuXHR9XHJcblxyXG5cdC8vIElmIHdlIGhhdmUgYSBkdWUgZGF0ZSBidXQgb25seSBzY2hlZHVsZWQgdGltZSwgdXNlIGl0IGZvciBzY2hlZHVsZWQgYW5kIGR1ZSBkYXRldGltZXNcclxuXHRpZiAobWV0YWRhdGEuZHVlRGF0ZSAmJiAhbWV0YWRhdGEuc2NoZWR1bGVkRGF0ZSAmJiB0aW1lQ29tcG9uZW50cy5zY2hlZHVsZWRUaW1lKSB7XHJcblx0XHRpZiAoIWVuaGFuY2VkRGF0ZXMuZHVlRGF0ZVRpbWUpIHtcclxuXHRcdFx0ZW5oYW5jZWREYXRlcy5kdWVEYXRlVGltZSA9IGNvbWJpbmVEYXRlQW5kVGltZShtZXRhZGF0YS5kdWVEYXRlLCB0aW1lQ29tcG9uZW50cy5zY2hlZHVsZWRUaW1lKTtcclxuXHRcdH1cclxuXHRcdGlmICghZW5oYW5jZWREYXRlcy5zY2hlZHVsZWREYXRlVGltZSkge1xyXG5cdFx0XHRlbmhhbmNlZERhdGVzLnNjaGVkdWxlZERhdGVUaW1lID0gY29tYmluZURhdGVBbmRUaW1lKG1ldGFkYXRhLmR1ZURhdGUsIHRpbWVDb21wb25lbnRzLnNjaGVkdWxlZFRpbWUpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gQ29tYmluZSBzY2hlZHVsZWQgZGF0ZSBhbmQgdGltZVxyXG5cdGlmIChtZXRhZGF0YS5zY2hlZHVsZWREYXRlICYmIHRpbWVDb21wb25lbnRzLnNjaGVkdWxlZFRpbWUpIHtcclxuXHRcdGVuaGFuY2VkRGF0ZXMuc2NoZWR1bGVkRGF0ZVRpbWUgPSBjb21iaW5lRGF0ZUFuZFRpbWUobWV0YWRhdGEuc2NoZWR1bGVkRGF0ZSwgdGltZUNvbXBvbmVudHMuc2NoZWR1bGVkVGltZSk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gZW5oYW5jZWREYXRlcztcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnQgc3RhbmRhcmQgdGFzayBtZXRhZGF0YSB0byBlbmhhbmNlZCBtZXRhZGF0YSB3aXRoIHRpbWUgY29tcG9uZW50c1xyXG4gKiBAcGFyYW0gbWV0YWRhdGEgLSBTdGFuZGFyZCB0YXNrIG1ldGFkYXRhXHJcbiAqIEBwYXJhbSB0aW1lQ29tcG9uZW50cyAtIE9wdGlvbmFsIHRpbWUgY29tcG9uZW50cyB0byBhZGRcclxuICogQHJldHVybnMgRW5oYW5jZWQgdGFzayBtZXRhZGF0YVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGVuaGFuY2VUYXNrTWV0YWRhdGEoXHJcblx0bWV0YWRhdGE6IFN0YW5kYXJkVGFza01ldGFkYXRhLFxyXG5cdHRpbWVDb21wb25lbnRzPzogTm9uTnVsbGFibGU8RW5oYW5jZWRTdGFuZGFyZFRhc2tNZXRhZGF0YVsndGltZUNvbXBvbmVudHMnXT5cclxuKTogRW5oYW5jZWRTdGFuZGFyZFRhc2tNZXRhZGF0YSB7XHJcblx0Y29uc3QgZW5oYW5jZWQ6IEVuaGFuY2VkU3RhbmRhcmRUYXNrTWV0YWRhdGEgPSB7XHJcblx0XHQuLi5tZXRhZGF0YVxyXG5cdH07XHJcblxyXG5cdGlmICh0aW1lQ29tcG9uZW50cykge1xyXG5cdFx0ZW5oYW5jZWQudGltZUNvbXBvbmVudHMgPSB0aW1lQ29tcG9uZW50cztcclxuXHRcdGVuaGFuY2VkLmVuaGFuY2VkRGF0ZXMgPSBjcmVhdGVFbmhhbmNlZERhdGVzKG1ldGFkYXRhLCB0aW1lQ29tcG9uZW50cyk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gZW5oYW5jZWQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFeHRyYWN0IHRpbWUgY29tcG9uZW50cyBmcm9tIGV4aXN0aW5nIHRpbWVzdGFtcHMgaW4gbWV0YWRhdGFcclxuICogQHBhcmFtIG1ldGFkYXRhIC0gU3RhbmRhcmQgdGFzayBtZXRhZGF0YSB3aXRoIHRpbWVzdGFtcHNcclxuICogQHJldHVybnMgVGltZSBjb21wb25lbnRzIGV4dHJhY3RlZCBmcm9tIHRpbWVzdGFtcHNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0VGltZUNvbXBvbmVudHNGcm9tTWV0YWRhdGEoXHJcblx0bWV0YWRhdGE6IFN0YW5kYXJkVGFza01ldGFkYXRhXHJcbik6IE5vbk51bGxhYmxlPEVuaGFuY2VkU3RhbmRhcmRUYXNrTWV0YWRhdGFbJ3RpbWVDb21wb25lbnRzJ10+IHtcclxuXHRjb25zdCB0aW1lQ29tcG9uZW50czogTm9uTnVsbGFibGU8RW5oYW5jZWRTdGFuZGFyZFRhc2tNZXRhZGF0YVsndGltZUNvbXBvbmVudHMnXT4gPSB7fTtcclxuXHJcblx0aWYgKG1ldGFkYXRhLnN0YXJ0RGF0ZSkge1xyXG5cdFx0dGltZUNvbXBvbmVudHMuc3RhcnRUaW1lID0gdGltZXN0YW1wVG9UaW1lQ29tcG9uZW50KG1ldGFkYXRhLnN0YXJ0RGF0ZSk7XHJcblx0fVxyXG5cclxuXHRpZiAobWV0YWRhdGEuZHVlRGF0ZSkge1xyXG5cdFx0dGltZUNvbXBvbmVudHMuZHVlVGltZSA9IHRpbWVzdGFtcFRvVGltZUNvbXBvbmVudChtZXRhZGF0YS5kdWVEYXRlKTtcclxuXHR9XHJcblxyXG5cdGlmIChtZXRhZGF0YS5zY2hlZHVsZWREYXRlKSB7XHJcblx0XHR0aW1lQ29tcG9uZW50cy5zY2hlZHVsZWRUaW1lID0gdGltZXN0YW1wVG9UaW1lQ29tcG9uZW50KG1ldGFkYXRhLnNjaGVkdWxlZERhdGUpO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHRpbWVDb21wb25lbnRzO1xyXG59XHJcblxyXG4vKipcclxuICogQmFja3dhcmQgY29tcGF0aWJpbGl0eSBoZWxwZXI6IGNvbnZlcnQgZW5oYW5jZWQgbWV0YWRhdGEgdG8gc3RhbmRhcmQgZm9ybWF0XHJcbiAqIEBwYXJhbSBlbmhhbmNlZCAtIEVuaGFuY2VkIHRhc2sgbWV0YWRhdGFcclxuICogQHJldHVybnMgU3RhbmRhcmQgdGFzayBtZXRhZGF0YSAobG9zZXMgdGltZSBjb21wb25lbnQgaW5mb3JtYXRpb24pXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZG93bmdyYWRlVG9TdGFuZGFyZE1ldGFkYXRhKGVuaGFuY2VkOiBFbmhhbmNlZFN0YW5kYXJkVGFza01ldGFkYXRhKTogU3RhbmRhcmRUYXNrTWV0YWRhdGEge1xyXG5cdGNvbnN0IHsgdGltZUNvbXBvbmVudHMsIGVuaGFuY2VkRGF0ZXMsIC4uLnN0YW5kYXJkIH0gPSBlbmhhbmNlZDtcclxuXHRcclxuXHQvLyBJZiB3ZSBoYXZlIGVuaGFuY2VkIGRhdGVzLCB1c2UgdGhvc2UgYXMgdGhlIHByaW1hcnkgdGltZXN0YW1wc1xyXG5cdGlmIChlbmhhbmNlZERhdGVzKSB7XHJcblx0XHRpZiAoZW5oYW5jZWREYXRlcy5zdGFydERhdGVUaW1lKSB7XHJcblx0XHRcdHN0YW5kYXJkLnN0YXJ0RGF0ZSA9IGVuaGFuY2VkRGF0ZXMuc3RhcnREYXRlVGltZS5nZXRUaW1lKCk7XHJcblx0XHR9XHJcblx0XHRpZiAoZW5oYW5jZWREYXRlcy5kdWVEYXRlVGltZSkge1xyXG5cdFx0XHRzdGFuZGFyZC5kdWVEYXRlID0gZW5oYW5jZWREYXRlcy5kdWVEYXRlVGltZS5nZXRUaW1lKCk7XHJcblx0XHR9XHJcblx0XHRpZiAoZW5oYW5jZWREYXRlcy5zY2hlZHVsZWREYXRlVGltZSkge1xyXG5cdFx0XHRzdGFuZGFyZC5zY2hlZHVsZWREYXRlID0gZW5oYW5jZWREYXRlcy5zY2hlZHVsZWREYXRlVGltZS5nZXRUaW1lKCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gc3RhbmRhcmQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiBtZXRhZGF0YSBoYXMgYW55IHRpbWUgY29tcG9uZW50c1xyXG4gKiBAcGFyYW0gbWV0YWRhdGEgLSBFbmhhbmNlZCB0YXNrIG1ldGFkYXRhXHJcbiAqIEByZXR1cm5zIFRydWUgaWYgbWV0YWRhdGEgY29udGFpbnMgdGltZSBjb21wb25lbnRzXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaGFzVGltZUNvbXBvbmVudHMobWV0YWRhdGE6IEVuaGFuY2VkU3RhbmRhcmRUYXNrTWV0YWRhdGEpOiBib29sZWFuIHtcclxuXHRyZXR1cm4gISEobWV0YWRhdGEudGltZUNvbXBvbmVudHMgJiYgKFxyXG5cdFx0bWV0YWRhdGEudGltZUNvbXBvbmVudHMuc3RhcnRUaW1lIHx8XHJcblx0XHRtZXRhZGF0YS50aW1lQ29tcG9uZW50cy5lbmRUaW1lIHx8XHJcblx0XHRtZXRhZGF0YS50aW1lQ29tcG9uZW50cy5kdWVUaW1lIHx8XHJcblx0XHRtZXRhZGF0YS50aW1lQ29tcG9uZW50cy5zY2hlZHVsZWRUaW1lXHJcblx0KSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBWYWxpZGF0ZSB0aW1lIGNvbXBvbmVudCB2YWx1ZXNcclxuICogQHBhcmFtIHRpbWVDb21wb25lbnQgLSBUaW1lIGNvbXBvbmVudCB0byB2YWxpZGF0ZVxyXG4gKiBAcmV0dXJucyBUcnVlIGlmIHZhbGlkLCBmYWxzZSBvdGhlcndpc2VcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVRpbWVDb21wb25lbnQodGltZUNvbXBvbmVudDogVGltZUNvbXBvbmVudCk6IGJvb2xlYW4ge1xyXG5cdHJldHVybiAoXHJcblx0XHR0aW1lQ29tcG9uZW50LmhvdXIgPj0gMCAmJiB0aW1lQ29tcG9uZW50LmhvdXIgPD0gMjMgJiZcclxuXHRcdHRpbWVDb21wb25lbnQubWludXRlID49IDAgJiYgdGltZUNvbXBvbmVudC5taW51dGUgPD0gNTkgJiZcclxuXHRcdCh0aW1lQ29tcG9uZW50LnNlY29uZCA9PT0gdW5kZWZpbmVkIHx8ICh0aW1lQ29tcG9uZW50LnNlY29uZCA+PSAwICYmIHRpbWVDb21wb25lbnQuc2Vjb25kIDw9IDU5KSlcclxuXHQpO1xyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlIGEgdGltZSBjb21wb25lbnQgZnJvbSBob3VyIGFuZCBtaW51dGUgdmFsdWVzXHJcbiAqIEBwYXJhbSBob3VyIC0gSG91ciAoMC0yMylcclxuICogQHBhcmFtIG1pbnV0ZSAtIE1pbnV0ZSAoMC01OSlcclxuICogQHBhcmFtIHNlY29uZCAtIE9wdGlvbmFsIHNlY29uZCAoMC01OSlcclxuICogQHBhcmFtIG9yaWdpbmFsVGV4dCAtIE9yaWdpbmFsIHRleHQgdGhhdCB3YXMgcGFyc2VkXHJcbiAqIEByZXR1cm5zIFRpbWVDb21wb25lbnQgb2JqZWN0XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVGltZUNvbXBvbmVudChcclxuXHRob3VyOiBudW1iZXIsXHJcblx0bWludXRlOiBudW1iZXIsXHJcblx0c2Vjb25kPzogbnVtYmVyLFxyXG5cdG9yaWdpbmFsVGV4dD86IHN0cmluZ1xyXG4pOiBUaW1lQ29tcG9uZW50IHtcclxuXHRjb25zdCB0aW1lQ29tcG9uZW50OiBUaW1lQ29tcG9uZW50ID0ge1xyXG5cdFx0aG91cixcclxuXHRcdG1pbnV0ZSxcclxuXHRcdHNlY29uZCxcclxuXHRcdG9yaWdpbmFsVGV4dDogb3JpZ2luYWxUZXh0IHx8IGAke2hvdXIudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpfToke21pbnV0ZS50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyl9JHtzZWNvbmQgIT09IHVuZGVmaW5lZCA/ICc6JyArIHNlY29uZC50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJykgOiAnJ31gLFxyXG5cdFx0aXNSYW5nZTogZmFsc2VcclxuXHR9O1xyXG5cclxuXHRpZiAoIXZhbGlkYXRlVGltZUNvbXBvbmVudCh0aW1lQ29tcG9uZW50KSkge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHRpbWUgY29tcG9uZW50OiAke2hvdXJ9OiR7bWludXRlfSR7c2Vjb25kICE9PSB1bmRlZmluZWQgPyAnOicgKyBzZWNvbmQgOiAnJ31gKTtcclxuXHR9XHJcblxyXG5cdHJldHVybiB0aW1lQ29tcG9uZW50O1xyXG59XHJcbiJdfQ==