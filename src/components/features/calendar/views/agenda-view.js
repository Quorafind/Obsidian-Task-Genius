import { moment } from "obsidian";
import { renderCalendarEvent } from "../rendering/event-renderer"; // Use new renderer
import { CalendarViewComponent } from "./base-view"; // Import base class
export class AgendaView extends CalendarViewComponent {
    constructor(app, plugin, // Added plugin dependency
    containerEl, currentDate, events, options = {} // Use base options, default to empty
    ) {
        super(plugin, app, containerEl, events, options); // Call base constructor
        this.app = app;
        this.plugin = plugin;
        this.currentDate = currentDate;
    }
    render() {
        this.containerEl.empty();
        this.containerEl.addClass("view-agenda");
        // 1. Define date range (e.g., next 7 days starting from currentDate)
        const rangeStart = this.currentDate.clone().startOf("day");
        const rangeEnd = this.currentDate.clone().add(6, "days").endOf("day"); // 7 days total
        // 2. Filter and Sort Events: Only include events whose START date is within the range
        const agendaEvents = this.events
            .filter((event) => {
            const eventStart = moment(event.start);
            // Only consider the start date for inclusion in the agenda range
            return eventStart.isBetween(rangeStart, rangeEnd, undefined, "[]");
        })
            .sort((a, b) => moment(a.start).valueOf() - moment(b.start).valueOf()); // Ensure sorting by start time
        // 3. Group events by their start day
        const eventsByDay = {};
        agendaEvents.forEach((event) => {
            // Get the start date string
            const dateStr = moment(event.start).format("YYYY-MM-DD");
            if (!eventsByDay[dateStr]) {
                eventsByDay[dateStr] = [];
            }
            // Add the event to its start date list
            eventsByDay[dateStr].push(event);
        });
        // 4. Render the list
        if (Object.keys(eventsByDay).length === 0) {
            this.containerEl.setText(`No upcoming events from ${rangeStart.format("MMM D")} to ${rangeEnd.format("MMM D, YYYY")}.`);
            return;
        }
        let currentDayIter = rangeStart.clone();
        while (currentDayIter.isSameOrBefore(rangeEnd, "day")) {
            const dateStr = currentDayIter.format("YYYY-MM-DD");
            if (eventsByDay[dateStr] && eventsByDay[dateStr].length > 0) {
                // Create a container for the two-column layout for the day
                const daySection = this.containerEl.createDiv("agenda-day-section");
                // Left column for the date
                const dateColumn = daySection.createDiv("agenda-day-date-column");
                const dayHeader = dateColumn.createDiv("agenda-day-header");
                dayHeader.textContent = currentDayIter.format("dddd, MMMM D");
                if (currentDayIter.isSame(moment(), "day")) {
                    dayHeader.addClass("is-today");
                }
                // Right column for the events
                const eventsColumn = daySection.createDiv("agenda-day-events-column");
                const eventsList = eventsColumn.createDiv("agenda-events-list"); // Keep the original list class if needed
                eventsByDay[dateStr]
                    .sort((a, b) => {
                    const timeA = a.start ? moment(a.start).valueOf() : 0;
                    const timeB = b.start ? moment(b.start).valueOf() : 0;
                    return timeA - timeB;
                })
                    .forEach((event) => {
                    const eventItem = eventsList.createDiv("agenda-event-item");
                    const { eventEl, component } = renderCalendarEvent({
                        event: event,
                        viewType: "agenda",
                        app: this.app,
                        onEventClick: this.options.onEventClick,
                        onEventHover: this.options.onEventHover,
                        onEventContextMenu: this.options.onEventContextMenu,
                        onEventComplete: this.options.onEventComplete,
                    });
                    this.addChild(component);
                    eventItem.appendChild(eventEl);
                });
            }
            currentDayIter.add(1, "day");
        }
        console.log(`Rendered Agenda View component from ${rangeStart.format("YYYY-MM-DD")} to ${rangeEnd.format("YYYY-MM-DD")}`);
    }
    // Update methods to allow changing data after initial render
    updateEvents(events) {
        this.events = events;
        this.render();
    }
    updateCurrentDate(date) {
        this.currentDate = date;
        this.render();
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWdlbmRhLXZpZXcuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJhZ2VuZGEtdmlldy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQWtCLE1BQU0sRUFBRSxNQUFNLFVBQVUsQ0FBQztBQUVsRCxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSw2QkFBNkIsQ0FBQyxDQUFDLG1CQUFtQjtBQUN0RixPQUFPLEVBQUUscUJBQXFCLEVBQXVCLE1BQU0sYUFBYSxDQUFDLENBQUMsb0JBQW9CO0FBRzlGLE1BQU0sT0FBTyxVQUFXLFNBQVEscUJBQXFCO0lBUXBELFlBQ0MsR0FBUSxFQUNSLE1BQTZCLEVBQUUsMEJBQTBCO0lBQ3pELFdBQXdCLEVBQ3hCLFdBQTBCLEVBQzFCLE1BQXVCLEVBQ3ZCLFVBQStCLEVBQUUsQ0FBQyxxQ0FBcUM7O1FBRXZFLEtBQUssQ0FBQyxNQUFNLEVBQUUsR0FBRyxFQUFFLFdBQVcsRUFBRSxNQUFNLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQyx3QkFBd0I7UUFDMUUsSUFBSSxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUM7UUFDZixJQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztRQUNyQixJQUFJLENBQUMsV0FBVyxHQUFHLFdBQVcsQ0FBQztJQUNoQyxDQUFDO0lBRUQsTUFBTTtRQUNMLElBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxFQUFFLENBQUM7UUFDekIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsYUFBYSxDQUFDLENBQUM7UUFFekMscUVBQXFFO1FBQ3JFLE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxFQUFFLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQzNELE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQyxLQUFLLENBQUMsS0FBSyxD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QUFDLEVBQUUsS0FBSyxDQUFDLENBQUM7U0FDN0I7UUFFRCxPQUFPLENBQUMsR0FBRyxDQUNWLHVDQUF1QyxVQUFVLENBQUMsTUFBTSxDQUN2RCxZQUFZLENBQ1osT0FBTyxRQUFRLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxFQUFFLENBQ3ZDLENBQUM7SUFDSCxDQUFDO0lBRUQsNkRBQTZEO0lBQzdELFlBQVksQ0FBQyxNQUF1QjtRQUNuQyxJQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztRQUNyQixJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7SUFDZixDQUFDO0lBRUQsaUJBQWlCLENBQUMsSUFBbUI7UUFDcEMsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUM7UUFDeEIsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO0lBQ2YsQ0FBQztDQUNEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQXBwLCBDb21wb25lbnQsIG1vbWVudCB9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5pbXBvcnQgeyBDYWxlbmRhckV2ZW50IH0gZnJvbSAnQC9jb21wb25lbnRzL2ZlYXR1cmVzL2NhbGVuZGFyL2luZGV4JztcclxuaW1wb3J0IHsgcmVuZGVyQ2FsZW5kYXJFdmVudCB9IGZyb20gXCIuLi9yZW5kZXJpbmcvZXZlbnQtcmVuZGVyZXJcIjsgLy8gVXNlIG5ldyByZW5kZXJlclxyXG5pbXBvcnQgeyBDYWxlbmRhclZpZXdDb21wb25lbnQsIENhbGVuZGFyVmlld09wdGlvbnMgfSBmcm9tIFwiLi9iYXNlLXZpZXdcIjsgLy8gSW1wb3J0IGJhc2UgY2xhc3NcclxuaW1wb3J0IFRhc2tQcm9ncmVzc0JhclBsdWdpbiBmcm9tIFwiQC9pbmRleFwiOyAvLyBJbXBvcnQgcGx1Z2luIHR5cGVcclxuXHJcbmV4cG9ydCBjbGFzcyBBZ2VuZGFWaWV3IGV4dGVuZHMgQ2FsZW5kYXJWaWV3Q29tcG9uZW50IHtcclxuXHQvLyBFeHRlbmQgYmFzZSBjbGFzc1xyXG5cdC8vIHByaXZhdGUgY29udGFpbmVyRWw6IEhUTUxFbGVtZW50OyAvLyBJbmhlcml0ZWRcclxuXHRwcml2YXRlIGN1cnJlbnREYXRlOiBtb21lbnQuTW9tZW50O1xyXG5cdC8vIHByaXZhdGUgZXZlbnRzOiBDYWxlbmRhckV2ZW50W107IC8vIEluaGVyaXRlZFxyXG5cdHByaXZhdGUgYXBwOiBBcHA7IC8vIEtlZXAgYXBwIHJlZmVyZW5jZVxyXG5cdHByaXZhdGUgcGx1Z2luOiBUYXNrUHJvZ3Jlc3NCYXJQbHVnaW47IC8vIEFkZGVkIGZvciBiYXNlIGNvbnN0cnVjdG9yXHJcblxyXG5cdGNvbnN0cnVjdG9yKFxyXG5cdFx0YXBwOiBBcHAsXHJcblx0XHRwbHVnaW46IFRhc2tQcm9ncmVzc0JhclBsdWdpbiwgLy8gQWRkZWQgcGx1Z2luIGRlcGVuZGVuY3lcclxuXHRcdGNvbnRhaW5lckVsOiBIVE1MRWxlbWVudCxcclxuXHRcdGN1cnJlbnREYXRlOiBtb21lbnQuTW9tZW50LFxyXG5cdFx0ZXZlbnRzOiBDYWxlbmRhckV2ZW50W10sXHJcblx0XHRvcHRpb25zOiBDYWxlbmRhclZpZXdPcHRpb25zID0ge30gLy8gVXNlIGJhc2Ugb3B0aW9ucywgZGVmYXVsdCB0byBlbXB0eVxyXG5cdCkge1xyXG5cdFx0c3VwZXIocGx1Z2luLCBhcHAsIGNvbnRhaW5lckVsLCBldmVudHMsIG9wdGlvbnMpOyAvLyBDYWxsIGJhc2UgY29uc3RydWN0b3JcclxuXHRcdHRoaXMuYXBwID0gYXBwO1xyXG5cdFx0dGhpcy5wbHVnaW4gPSBwbHVnaW47XHJcblx0XHR0aGlzLmN1cnJlbnREYXRlID0gY3VycmVudERhdGU7XHJcblx0fVxyXG5cclxuXHRyZW5kZXIoKTogdm9pZCB7XHJcblx0XHR0aGlzLmNvbnRhaW5lckVsLmVtcHR5KCk7XHJcblx0XHR0aGlzLmNvbnRhaW5lckVsLmFkZENsYXNzKFwidmlldy1hZ2VuZGFcIik7XHJcblxyXG5cdFx0Ly8gMS4gRGVmaW5lIGRhdGUgcmFuZ2UgKGUuZy4sIG5leHQgNyBkYXlzIHN0YXJ0aW5nIGZyb20gY3VycmVudERhdGUpXHJcblx0XHRjb25zdCByYW5nZVN0YXJ0ID0gdGhpcy5jdXJyZW50RGF0ZS5jbG9uZSgpLnN0YXJ0T2YoXCJkYXlcIik7XHJcblx0XHRjb25zdCByYW5nZUVuZCA9IHRoaXMuY3VycmVudERhdGUuY2xvbmUoKS5hZGQoNiwgXCJkYXlzXCIpLmVuZE9mKFwiZGF5XCIpOyAvLyA3IGRheXMgdG90YWxcclxuXHJcblx0XHQvLyAyLiBGaWx0ZXIgYW5kIFNvcnQgRXZlbnRzOiBPbmx5IGluY2x1ZGUgZXZlbnRzIHdob3NlIFNUQVJUIGRhdGUgaXMgd2l0aGluIHRoZSByYW5nZVxyXG5cdFx0Y29uc3QgYWdlbmRhRXZlbnRzID0gdGhpcy5ldmVudHNcclxuXHRcdFx0LmZpbHRlcigoZXZlbnQpID0+IHtcclxuXHRcdFx0XHRjb25zdCBldmVudFN0YXJ0ID0gbW9tZW50KGV2ZW50LnN0YXJ0KTtcclxuXHRcdFx0XHQvLyBPbmx5IGNvbnNpZGVyIHRoZSBzdGFydCBkYXRlIGZvciBpbmNsdXNpb24gaW4gdGhlIGFnZW5kYSByYW5nZVxyXG5cdFx0XHRcdHJldHVybiBldmVudFN0YXJ0LmlzQmV0d2VlbihcclxuXHRcdFx0XHRcdHJhbmdlU3RhcnQsXHJcblx0XHRcdFx0XHRyYW5nZUVuZCxcclxuXHRcdFx0XHRcdHVuZGVmaW5lZCxcclxuXHRcdFx0XHRcdFwiW11cIlxyXG5cdFx0XHRcdCk7XHJcblx0XHRcdH0pXHJcblx0XHRcdC5zb3J0KFxyXG5cdFx0XHRcdChhLCBiKSA9PiBtb21lbnQoYS5zdGFydCkudmFsdWVPZigpIC0gbW9tZW50KGIuc3RhcnQpLnZhbHVlT2YoKVxyXG5cdFx0XHQpOyAvLyBFbnN1cmUgc29ydGluZyBieSBzdGFydCB0aW1lXHJcblxyXG5cdFx0Ly8gMy4gR3JvdXAgZXZlbnRzIGJ5IHRoZWlyIHN0YXJ0IGRheVxyXG5cdFx0Y29uc3QgZXZlbnRzQnlEYXk6IHsgW2tleTogc3RyaW5nXTogQ2FsZW5kYXJFdmVudFtdIH0gPSB7fTtcclxuXHRcdGFnZW5kYUV2ZW50cy5mb3JFYWNoKChldmVudCkgPT4ge1xyXG5cdFx0XHQvLyBHZXQgdGhlIHN0YXJ0IGRhdGUgc3RyaW5nXHJcblx0XHRcdGNvbnN0IGRhdGVTdHIgPSBtb21lbnQoZXZlbnQuc3RhcnQpLmZvcm1hdChcIllZWVktTU0tRERcIik7XHJcblxyXG5cdFx0XHRpZiAoIWV2ZW50c0J5RGF5W2RhdGVTdHJdKSB7XHJcblx0XHRcdFx0ZXZlbnRzQnlEYXlbZGF0ZVN0cl0gPSBbXTtcclxuXHRcdFx0fVxyXG5cdFx0XHQvLyBBZGQgdGhlIGV2ZW50IHRvIGl0cyBzdGFydCBkYXRlIGxpc3RcclxuXHRcdFx0ZXZlbnRzQnlEYXlbZGF0ZVN0cl0ucHVzaChldmVudCk7XHJcblx0XHR9KTtcclxuXHJcblx0XHQvLyA0LiBSZW5kZXIgdGhlIGxpc3RcclxuXHRcdGlmIChPYmplY3Qua2V5cyhldmVudHNCeURheSkubGVuZ3RoID09PSAwKSB7XHJcblx0XHRcdHRoaXMuY29udGFpbmVyRWwuc2V0VGV4dChcclxuXHRcdFx0XHRgTm8gdXBjb21pbmcgZXZlbnRzIGZyb20gJHtyYW5nZVN0YXJ0LmZvcm1hdChcclxuXHRcdFx0XHRcdFwiTU1NIERcIlxyXG5cdFx0XHRcdCl9IHRvICR7cmFuZ2VFbmQuZm9ybWF0KFwiTU1NIEQsIFlZWVlcIil9LmBcclxuXHRcdFx0KTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBjdXJyZW50RGF5SXRlciA9IHJhbmdlU3RhcnQuY2xvbmUoKTtcclxuXHRcdHdoaWxlIChjdXJyZW50RGF5SXRlci5pc1NhbWVPckJlZm9yZShyYW5nZUVuZCwgXCJkYXlcIikpIHtcclxuXHRcdFx0Y29uc3QgZGF0ZVN0ciA9IGN1cnJlbnREYXlJdGVyLmZvcm1hdChcIllZWVktTU0tRERcIik7XHJcblx0XHRcdGlmIChldmVudHNCeURheVtkYXRlU3RyXSAmJiBldmVudHNCeURheVtkYXRlU3RyXS5sZW5ndGggPiAwKSB7XHJcblx0XHRcdFx0Ly8gQ3JlYXRlIGEgY29udGFpbmVyIGZvciB0aGUgdHdvLWNvbHVtbiBsYXlvdXQgZm9yIHRoZSBkYXlcclxuXHRcdFx0XHRjb25zdCBkYXlTZWN0aW9uID1cclxuXHRcdFx0XHRcdHRoaXMuY29udGFpbmVyRWwuY3JlYXRlRGl2KFwiYWdlbmRhLWRheS1zZWN0aW9uXCIpO1xyXG5cclxuXHRcdFx0XHQvLyBMZWZ0IGNvbHVtbiBmb3IgdGhlIGRhdGVcclxuXHRcdFx0XHRjb25zdCBkYXRlQ29sdW1uID0gZGF5U2VjdGlvbi5jcmVhdGVEaXYoXHJcblx0XHRcdFx0XHRcImFnZW5kYS1kYXktZGF0ZS1jb2x1bW5cIlxyXG5cdFx0XHRcdCk7XHJcblx0XHRcdFx0Y29uc3QgZGF5SGVhZGVyID0gZGF0ZUNvbHVtbi5jcmVhdGVEaXYoXCJhZ2VuZGEtZGF5LWhlYWRlclwiKTtcclxuXHRcdFx0XHRkYXlIZWFkZXIudGV4dENvbnRlbnQgPSBjdXJyZW50RGF5SXRlci5mb3JtYXQoXCJkZGRkLCBNTU1NIERcIik7XHJcblx0XHRcdFx0aWYgKGN1cnJlbnREYXlJdGVyLmlzU2FtZShtb21lbnQoKSwgXCJkYXlcIikpIHtcclxuXHRcdFx0XHRcdGRheUhlYWRlci5hZGRDbGFzcyhcImlzLXRvZGF5XCIpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gUmlnaHQgY29sdW1uIGZvciB0aGUgZXZlbnRzXHJcblx0XHRcdFx0Y29uc3QgZXZlbnRzQ29sdW1uID0gZGF5U2VjdGlvbi5jcmVhdGVEaXYoXHJcblx0XHRcdFx0XHRcImFnZW5kYS1kYXktZXZlbnRzLWNvbHVtblwiXHJcblx0XHRcdFx0KTtcclxuXHRcdFx0XHRjb25zdCBldmVudHNMaXN0ID0gZXZlbnRzQ29sdW1uLmNyZWF0ZURpdihcImFnZW5kYS1ldmVudHMtbGlzdFwiKTsgLy8gS2VlcCB0aGUgb3JpZ2luYWwgbGlzdCBjbGFzcyBpZiBuZWVkZWRcclxuXHJcblx0XHRcdFx0ZXZlbnRzQnlEYXlbZGF0ZVN0cl1cclxuXHRcdFx0XHRcdC5zb3J0KChhLCBiKSA9PiB7XHJcblx0XHRcdFx0XHRcdGNvbnN0IHRpbWVBID0gYS5zdGFydCA/IG1vbWVudChhLnN0YXJ0KS52YWx1ZU9mKCkgOiAwO1xyXG5cdFx0XHRcdFx0XHRjb25zdCB0aW1lQiA9IGIuc3RhcnQgPyBtb21lbnQoYi5zdGFydCkudmFsdWVPZigpIDogMDtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIHRpbWVBIC0gdGltZUI7XHJcblx0XHRcdFx0XHR9KVxyXG5cdFx0XHRcdFx0LmZvckVhY2goKGV2ZW50KSA9PiB7XHJcblx0XHRcdFx0XHRcdGNvbnN0IGV2ZW50SXRlbSA9XHJcblx0XHRcdFx0XHRcdFx0ZXZlbnRzTGlzdC5jcmVhdGVEaXYoXCJhZ2VuZGEtZXZlbnQtaXRlbVwiKTtcclxuXHRcdFx0XHRcdFx0Y29uc3QgeyBldmVudEVsLCBjb21wb25lbnQgfSA9IHJlbmRlckNhbGVuZGFyRXZlbnQoe1xyXG5cdFx0XHRcdFx0XHRcdGV2ZW50OiBldmVudCxcclxuXHRcdFx0XHRcdFx0XHR2aWV3VHlwZTogXCJhZ2VuZGFcIixcclxuXHRcdFx0XHRcdFx0XHRhcHA6IHRoaXMuYXBwLFxyXG5cdFx0XHRcdFx0XHRcdG9uRXZlbnRDbGljazogdGhpcy5vcHRpb25zLm9uRXZlbnRDbGljayxcclxuXHRcdFx0XHRcdFx0XHRvbkV2ZW50SG92ZXI6IHRoaXMub3B0aW9ucy5vbkV2ZW50SG92ZXIsXHJcblx0XHRcdFx0XHRcdFx0b25FdmVudENvbnRleHRNZW51OiB0aGlzLm9wdGlvbnMub25FdmVudENvbnRleHRNZW51LFxyXG5cdFx0XHRcdFx0XHRcdG9uRXZlbnRDb21wbGV0ZTogdGhpcy5vcHRpb25zLm9uRXZlbnRDb21wbGV0ZSxcclxuXHRcdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0XHRcdHRoaXMuYWRkQ2hpbGQoY29tcG9uZW50KTtcclxuXHRcdFx0XHRcdFx0ZXZlbnRJdGVtLmFwcGVuZENoaWxkKGV2ZW50RWwpO1xyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHRcdFx0Y3VycmVudERheUl0ZXIuYWRkKDEsIFwiZGF5XCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnNvbGUubG9nKFxyXG5cdFx0XHRgUmVuZGVyZWQgQWdlbmRhIFZpZXcgY29tcG9uZW50IGZyb20gJHtyYW5nZVN0YXJ0LmZvcm1hdChcclxuXHRcdFx0XHRcIllZWVktTU0tRERcIlxyXG5cdFx0XHQpfSB0byAke3JhbmdlRW5kLmZvcm1hdChcIllZWVktTU0tRERcIil9YFxyXG5cdFx0KTtcclxuXHR9XHJcblxyXG5cdC8vIFVwZGF0ZSBtZXRob2RzIHRvIGFsbG93IGNoYW5naW5nIGRhdGEgYWZ0ZXIgaW5pdGlhbCByZW5kZXJcclxuXHR1cGRhdGVFdmVudHMoZXZlbnRzOiBDYWxlbmRhckV2ZW50W10pOiB2b2lkIHtcclxuXHRcdHRoaXMuZXZlbnRzID0gZXZlbnRzO1xyXG5cdFx0dGhpcy5yZW5kZXIoKTtcclxuXHR9XHJcblxyXG5cdHVwZGF0ZUN1cnJlbnREYXRlKGRhdGU6IG1vbWVudC5Nb21lbnQpOiB2b2lkIHtcclxuXHRcdHRoaXMuY3VycmVudERhdGUgPSBkYXRlO1xyXG5cdFx0dGhpcy5yZW5kZXIoKTtcclxuXHR9XHJcbn1cclxuIl19