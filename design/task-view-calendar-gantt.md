# PRD：Obsidian 插件的日历与甘特图视图 (原生实现侧重)

**版本:** 1.0
**日期:** 2025-04-15

## 1. 引言

本文档概述了在 Obsidian 插件中实现日历（Calendar）和甘特图（Gantt chart）视图的需求。这些视图旨在为用户提供其任务的可视化表示，从而在 Obsidian 内部改善计划、跟踪和整体任务管理工作流程。**核心目标是尽可能使用原生 Web 技术 (HTML, CSS, SVG/Canvas) 进行实现，** 并将利用 `TaskIndex.ts` 已索引的任务数据。

## 2. 目标

*   为用户提供直观的任务日历和甘特图可视化。
*   实现更好的基于日期的计划和进度跟踪。
*   高效利用现有的 `Task` 数据结构 (`src/utils/types/TaskIndex.ts`)。
*   提供交互式元素用于任务检查，并可能支持基本修改（例如，重新安排）。
*   即使存在大量任务，也能确保良好的性能 **(需要特别关注手动优化)**。
*   将视图无缝集成到 Obsidian 用户界面中。

## 3. 目标用户

在笔记中管理任务并希望使用可视化工具来规划和跟踪项目时间表和截止日期的 Obsidian 用户。这包括项目经理、学生、开发人员、作家以及任何使用 Obsidian 进行任务管理的人员。

## 4. 核心功能

### 4.1. 数据基础

*   **来源:** 所有任务数据将来源于 `TaskIndexer` 组件及其缓存。
*   **相关的 `Task` 字段:**
    *   `id`: 唯一标识符。
    *   `content`: 任务描述。
    *   `filePath`, `line`: 用于链接回源文件。
    *   `completed`, `status`: 用于可视化状态指示器。
    *   `startDate`, `scheduledDate`, `dueDate`, `completedDate`: 用于在时间线/日历上放置任务的主要字段。
    *   `project`: 用于过滤和分组。
    *   `tags`: 用于过滤。
    *   `priority`: 用于可视化高亮或排序。
    *   `parent`, `children`: 用于甘特图中的层级显示。

### 4.2. 日历视图

*   **显示模式:** 月、周、日视图。
*   **任务放置:**
    *   任务将主要根据其 `dueDate`（截止日期）放置。
    *   提供一个选项（用户设置）以使用 `scheduledDate`（计划日期）或 `startDate`（开始日期）作为放置的主要日期。
    *   跨越多天的任务（如果 `startDate` 和 `dueDate` 都可用）应在视觉上跨越这些天（在月视图中可能受限）。
    *   没有相关日期的任务可能会根据用户偏好显示在一个单独的"未安排"面板中或隐藏。
*   **可视化表示:**
    *   在日历单元格内显示任务 `content`（如有必要则截断）。
    *   使用视觉提示（颜色、图标）来指示状态 (`completed`)、优先级或项目。
    *   考虑根据任务映射到的日期字段（`dueDate`, `scheduledDate`, `startDate`）使用不同的视觉样式。
*   **交互性:**
    *   鼠标悬停在任务上时，在工具提示中显示完整的 `content` 和关键细节（日期、项目、状态）。
    *   点击任务可以导航到源文件/行或打开一个详细信息模态框。
    *   **(可选 V2)** 拖放重新安排：允许将任务拖动到不同的日期以更新其 `dueDate` / `scheduledDate` / `startDate`（需要调用 `TaskIndexer.updateTask`）。
*   **导航与过滤:**
    *   用于在上一/下一周期（月、周、日）之间导航的控件。
    *   一个"今天"按钮。
    *   基于 `project`, `tags`, `status`, `filePath` 的过滤选项。

### 4.3. 甘特图视图

*   **时间线显示:**
    *   水平轴代表时间（日、周、月缩放级别）。
    *   垂直轴列出任务。
*   **任务表示:**
    *   同时具有 `startDate` 和 `dueDate` 的任务显示为跨越该持续时间的条形。
    *   只有一个相关日期（`dueDate` 或 `startDate`）的任务在该日期显示为里程碑（例如，菱形）。
    *   任务条应显示 `content`（截断）。
    *   根据 `project` 或 `status` 对条形进行颜色编码。
    *   在条形上视觉指示完成进度（例如，填充部分）。
*   **层级结构:**
    *   利用 `parent` 和 `children` 字段以层级树结构显示任务（例如，使用缩进和折叠/展开控件）。子任务应在视觉上嵌套在父任务下。
*   **依赖关系:**
    *   **(可选 V2/V3)** 如果建立了可靠的定义依赖关系的机制（例如，特定的链接语法 `dependsOn:[[task-id]]` 或 `blocks:[[task-id]]`），则可视化任务依赖关系。在依赖的任务之间绘制箭头。*由于数据模型的限制，初始版本可能会省略明确的依赖线。*
*   **交互性:**
    *   鼠标悬停在任务条/里程碑上时，在工具提示中显示完整细节。
    *   点击可导航到源文件或打开详细信息模态框。
    *   时间线的水平滚动和缩放（放大/缩小）。
    *   任务列表的垂直滚动。
    *   **(可选 V2)** 拖放调整 `startDate` / `dueDate`。拖动条形的两端或整个条形。
*   **过滤与排序:**
    *   类似于日历视图的过滤选项 (`project`, `tags`, `status`, `filePath`)。
    *   任务列表的排序选项（例如，按 `startDate`, `dueDate`, `priority`, `content`）。

## 5. 非目标（初期）

*   直接从日历/甘特图视图创建新任务（首先关注可视化）。
*   高级资源分配或关键路径分析。
*   高度复杂的依赖类型（完成-开始，开始-开始等），除非可以轻松推导。
*   实时多用户协作功能。

## 6. 实现步骤

1.  **技术选型与基础:**
    *   **主要技术:** 使用 TypeScript、HTML、CSS 以及可能的 SVG 或 Canvas 进行核心渲染和交互逻辑。如果插件已使用 Svelte，则优先利用 Svelte 构建组件。
    *   **第三方库:** **原则上避免使用大型 UI/图表库 (如 FullCalendar, Frappe Gantt 等)。** 只有在遇到极其复杂且独立的算法问题（例如，高效的二维空间重叠检测、复杂的布局算法）且自研成本过高时，才考虑引入 **小型、专注** 的辅助库。任何引入的库都需要仔细评估其大小、性能和许可证。
2.  **视图搭建:** 为日历和甘特图创建新的 Obsidian `ItemView` 类。使用选定的基础技术（原生 DOM 或 Svelte）构建视图的基本结构和布局。
3.  **数据获取与转换:**
    *   访问 `TaskIndexer` 实例。
    *   在每个视图中，使用 `TaskIndexer.getCache()` 或 `TaskIndexer.queryTasks()` 获取任务数据。
    *   **手动** 将 `Task` 对象转换为适合在视图中渲染的结构（例如，计算日历单元格位置、甘特图条形坐标和尺寸）。密切关注日期对象的处理和转换。
4.  **渲染逻辑:**
    *   **手动实现渲染逻辑。** 基于转换后的数据，使用 DOM 操作、SVG 元素创建或 Canvas 绘图 API 来绘制日历网格、任务条目、甘特图时间轴和任务。
    *   实现切换视图模式（月/周/日）或缩放级别时 **重新计算布局和重新渲染** 的逻辑。
5.  **交互性实现:**
    *   **手动** 绑定事件监听器 (e.g., `mouseover`, `click`, `mousedown`, `mousemove`, `mouseup`) 来实现工具提示、点击导航/模态框以及拖放功能。
    *   对于拖放，需要手动计算拖动过程中的元素位置、检测放置目标、更新 `Task` 对象并调用 `TaskIndexer.updateTask`，最后刷新视图。对高频事件（如 `mousemove`）使用防抖/节流。
6.  **过滤/排序 UI:** 添加用于过滤和排序的 UI 控件（原生 HTML 或 Svelte 组件）。实现当控件更改时重新获取/重新过滤数据并 **触发视图重新渲染** 的逻辑。
7.  **样式:** 应用 CSS 以确保视图与 Obsidian 的主题匹配并具有视觉吸引力。利用 Obsidian CSS 变量。重点关注布局、定位和自定义元素的视觉样式。
8.  **优化:** **这是原生实现的关键环节。**
    *   使用大量任务对视图进行性能分析。
    *   **手动实现性能优化:**
        *   **DOM 优化:** 减少 DOM 操作次数，使用 `requestAnimationFrame` 调度更新，考虑 DOM diffing 或 Svelte 的响应式更新（如果使用）。
        *   **渲染优化:** 对于甘特图等可能包含大量元素的视图，实现 **视口虚拟化**（仅渲染可见区域内的元素）。对于 Canvas，优化绘图调用。对于 SVG，管理元素数量。
        *   **事件处理优化:** 对滚动、缩放、拖动等高频事件使用防抖/节流。
        *   **数据处理优化:** 确保数据转换和布局计算高效。

## 7. 关键考虑因素

*   **性能:** **(更加关键)** 由于缺少库的内置优化，需要开发者投入大量精力进行手动性能调优，尤其是在处理大量任务时。
*   **开发复杂度:** 从零开始构建复杂的日历和甘特图 UI 比使用现有库需要更多的时间和精力，特别是在处理布局、交互和跨浏览器/平台一致性方面。
*   **日期处理:** 使用健壮的日期库（例如 `moment.js` 或 `date-fns` - 检查 Obsidian 或其他插件可能已包含哪些以最小化体积）。一致地处理时区（Obsidian/系统默认或 UTC）。明确定义如何处理缺少 `startDate`/`dueDate` 的任务。
*   **状态管理:** 有效管理视图的状态（当前日期范围、过滤器、缩放级别）。
*   **错误处理:** 优雅地处理数据获取、转换或渲染过程中的错误。
*   **任务更新:** 确保通过 `TaskIndexer.updateTask`（例如，通过拖放）进行的更新能正确地将更改持久化回 Markdown 文件。向用户提供成功/失败的反馈。
*   **代码可维护性:** 自定义实现的 UI 代码可能比使用标准化库更难维护，需要良好的代码结构和文档。
*   **配置:** 提供用户设置来自定义视图行为（例如，默认日期字段、未安排任务的可见性、日期格式）。

## 8. 潜在挑战与解决方案

*   **挑战:** **从零开始构建 UI 的复杂性与工作量。**
    *   **解决方案:**
        *   **分阶段实现:** 从最核心的功能（例如，基本的月视图、无交互的甘特图条）开始，逐步迭代添加更复杂的功能（周/日视图、缩放、拖放、层级）。
        *   **抽象与组件化:** 即使不使用外部框架，也要将 UI 逻辑分解为可重用的函数或类/组件（如果使用 Svelte）。
        *   **专注核心价值:** 优先实现对用户最有价值的功能，对于复杂但次要的功能（如复杂的依赖线绘制）可以推迟或简化。
*   **挑战:** **手动实现高性能渲染和虚拟化。**
    *   **解决方案:**
        *   **深入理解渲染瓶颈:** 使用浏览器开发者工具分析性能，找出是 DOM 操作、计算还是绘制过程的瓶颈。
        *   **学习虚拟滚动技术:** 研究常见的虚拟滚动实现模式，并将其应用于任务列表和时间轴。
        *   **按需渲染:** 确保仅在数据或视图状态实际更改时才重新渲染，并尽可能只更新变化的部分。
*   **挑战:** 处理各种交互（拖放、缩放、滚动）的细节和边缘情况。
    *   **解决方案:**
        *   **仔细规划交互逻辑:** 在编码前明确定义每次交互的状态转换和预期行为。
        *   **单元测试:** 为交互逻辑编写测试用例，覆盖各种场景。
        *   **参考现有实现:** 研究开源项目或文章中类似交互的实现方式（即使不直接使用代码）。
*   **挑战:** 双向数据同步（UI <-> Markdown）。
    *   **解决方案:** 依赖 `TaskIndexer` 的 `updateTask` 和 `deleteTask`。确保更新是具体的，并针对正确的行/任务。处理在视图外部可能发生的文件修改或竞态条件。在索引器成功更新后刷新视图。
*   **挑战:** 处理多样化的日期格式和部分日期。
    *   **解决方案:** 解析后内部统一使用 ISO 8601 / Unix 时间戳。直接使用 `TaskIndexer` 的日期字段，因为它们应该已经被解析为 `number`（时间戳）。为缺少 `startDate` 或 `dueDate` 的任务定义清晰的逻辑（例如，视为里程碑，根据可用日期放置，省略）。
